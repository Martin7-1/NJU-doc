# Database Management

[toc]

> 南京大学软件学院大二下课程 数据管理基础 笔记（个人向）



## 1 计算、数据与数据管理

### 1.1 数据库的4个基本概念

数据、数据库、数据库管理系统和数据库系统是与数据库技术密切相关的4个基本概念。

#### 1.1.1 数据

> Data

数据是数据库中存储的基本对象，对数据我们可以做如下定义：**描述事务的符号记录称为数据**。数据的含义称为数据的语义，数据与其语义是不可分的。

> （李明，男，199505，江苏省南京市，计算机系，2013）这一串数据的语义即代表姓名，性别，出生年月，出生地点，所在院系，入学时间。

#### 1.1.2 数据库

> Database，DB

数据库是存放数据的仓库，且数据是按照一定格式存放的。严格地讲，<span style='color: orange'>**数据库是长期存储在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度（redundancy）、较高的数据独立性（data independency）和易扩展性（scalability）**</span>并可为各种用户共享。数据库数据具有永久存储、有组织和可共享三个基本特点。

**数据库的特点**

1. 数据按一定的数据模型组织、描述和储存
2. 可为各种用户共享
3. 冗余度较小
4. 数据独立性较高
5. 易扩展

#### 1.1.3 数据库管理系统

> Database Management System, DBMS

数据库管理系统是一个用来科学地组织和存储数据，高效地获取和维护数据的系统软件，是位于用户和操作系统之间的一层数据管理软件。它的功能主要有以下几个方面：

1. **数据定义功能**：数据库管理系统提供**数据定义语言**（Data Definition Language, DDL），用户通过它可以方便地对数据库中的数据对象的组成与结构进行定义
2. **数据组织、存储和管理**：实现数据之间的联系
3. **数据操纵功能**：数据库管理系统还提供**数据操纵语言**（Data Manipulation Language, DML），用户可以使用它实现对数据库的基本操作，如查询、插入、删除和修改等。
4. **数据库的事务管理和运行管理**
	1. 数据库在建立、运行和维护时由数据库管理系统统一管理和控制
	2. 保证数据的安全性、完整性、多用户对数据的并发使用
	3. 发生故障后的系统恢复
5. **数据库的建立和维护功能**
	1. 数据库初始数据的装载和转换
	2. 数据库转储、恢复功能
	3. 数据库的重组织
	4. 性能监视、分析等
6. **其他功能**

#### 1.1.4 数据库系统

> Database System, DBS

数据库系统是由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（Database Administrator, DBA）共同组成的存储、管理、处理和维护数据的系统。



### 1.2  数据管理技术的产生和发展

> 历史发展，略

大概要说明的是数据库发展经历了 **人工管理阶段 - 文件系统阶段 - 数据库系统阶段**。



### 1.3 数据库系统的特点

#### 1.3.1 数据结构化

数据库系统实现整体数据的**结构化**，这是数据库的主要特征之一，也是数据库系统与文件系统的本质区别。所谓“整体”结构化是指数据库中的数据不再仅仅针对某一个应用，而是面向整个组织或企业；不仅数据内部是结构化的，而且整体是结构化的数据之间是具有联系的。

#### 1.3.2 数据的共享性高、冗余度低且易扩充

数据共享可以大大减少数据冗余，节约存储空间。数据共享还能避免数据之间的不相容性与不一致性。

> 多个用户所拥有的同个对象的信息不同，该如何确定？首先，用户从数据库取出的对象信息是一致的，然后在自己的作用域中进行修改，在存储过程中，**数据库管理系统**发挥作用来判断哪个用户的更改是有效的，哪个用户的更改是无效的。

#### 1.3.2 数据独立性高

数据独立性包括**物理独立性**和**逻辑独立性**

1. **物理独立性**是指用户的应用程序与数据库中数据的物理存储是相互独立的。也就是说用户不需要了解数据在数据库中是怎样存储的。
2. **逻辑独立性**是指用户的应用程序与数据库的逻辑结构是相互独立的。也就是说，数据的逻辑结构改变时用户程序也可以不变。



## 2 数据模型

数据模型是对现实世界数据特征的抽象，用以**抽象、表示和处理**现实世界中的数据和信息。

数据模型应该要满足三方面的要求：

1. 能比较真实地模拟现实世界
2. 容易为人所理解
3. 便于在计算机上实现

数据模型是数据库系统的<span style='color: red'>**核心和基础**</span>



### 2.1 数据模型的分类

数据模型分成概念、逻辑、物理模型三大类。

1. 概念模型，也称为信息模型。是**按照用户的观点**来对数据和信息建模，用于数据库设计

2. 逻辑模型是**按照计算机系统的观点**对数据建模，用于DBMS实现

	主要包括：

	1. 网状模型
	2. 层次模型
	3. 关系模型
	4. 面向对象数据模型
	5. 对象关系数据模型
	6. 半结构化数据模型
	7. ...

3. 物理模型是对数据最底层的抽象，描述数据在系统内部的表示方法和存取方法。



### 2.2 客观对象的抽象过程 -- 两部抽象

1. 现实世界中的客观对象抽象为概念模型

	> 将现实世界抽象为信息世界

2. 把概念模型转换为特定DBMS支持的数据模型

	> 将信息世界转换为机器世界

![](https://s2.loli.net/2022/02/18/DwghMWKGPv2X8Ns.png)



### 2.3 数据模型的组成要素

#### 2.3.1 数据结构

数据模型的数据结构：描述数据库的组成对象，以及对象之间的联系。

描述的内容：

1. 与对象的类型、内容、性质有关
2. 与数据之间的联系有关

> 数据结构是对系统**静态特征**的描述

#### 2.3.2 数据操作

**数据操作**是对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则。

数据操作的类型：

1. 查询
2. 更新：包括插入、删除、修改

数据模型对操作的定义：

1. 操作的确切含义、操作符号、操作规则（如优先级）
2. 实现操作的语言

> 数据操作是对系统动态特性的描述

#### 2.3.3 数据的完整性约束条件

数据的完整性约束条件是**一组完整性规则的集合**

1. 完整性规则：给定的数据模型中数据及其联系所具有的制约和依存规则
2. 用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容。

数据模型对完整性约束条件的定义：

1. 反映和规定必须遵守的基本的通用的完整性约束条件
2. 提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件。



## 3 概念模型

### 3.1 概念模型的用途

1. 概念模型用于信息世界的建模
2. 是现实世界到机器世界的一个中间层次
3. 是数据库设计的有力工具
4. 数据库设计人员和用户之间进行交流的语言



### 3.2 对概念模型的基本要求

1. 较强的语义表达能力
2. 简单。清晰、易于用户理解



### 3.3 信息世界中的基本概念

1. **实体（Entity）**：客观存在并可相互区别的事物称为实体。可以是具体的人。事、物或抽象的概念
2. **属性（Attribute）**：实体所具有的某一特性称为属性。一个实体可以由若干个属性来刻画
3. **码（Key）**：唯一标识实体的属性集称为码
4. **实体型（Entity Type）**：用实体名及其属性名集合来抽象和刻画同类实体称为实体型
5. **实体集（Entity Set）**：同一类型实体的集合称为实体集
6. **联系（Relationship）**：现实世界中事物内部以及事物之间的联系在信息世界中反映为实体（型）内部的联系和实体（型）之间的联系。



### 3.3 实体联系方法

> Entity-Relationship Approach

* 用**E-R图**来描述现实世界的概念模型
* **E-R方法**也称为E-R模型
* 实体：方形
* 属性：椭圆
* 联系：菱形

![](https://s2.loli.net/2022/02/18/NO29D1mlUy7qzCf.png)

![](https://s2.loli.net/2022/02/18/7QVg1NJwWRvCmxc.png)





## 4 逻辑模型

常用数据模型

1. 格式化模型
	* 层次模型（Hierarchical Model）
	* 网状模型（Network Model）
2. 关系模型（Relational Model）
3. 对象模型
	* 面向对象数据模型（Object Oriented Data Model）
	* 对象关系数据模型（Object Relational Data Model）



### 4.1 关系模型

关系模型中数据的逻辑结构是一张二维表，它由行和列组成

![](https://s2.loli.net/2022/02/20/MkFNGtcehu9DXAC.png)

> 行代表元组，列代表属性

#### 4.1.1关系模型中的一些概念

* **关系（Relation）**：一个关系对应通常说的一张表
* **元组（Tuple）**：表中的一行即为一个元组
* **属性（Attribute）**：表中的一列即为一个属性，给每个属性起一个名称即属性名
* **主码（Key）**：也称为码键。表中的某个属性组，它可以唯一确定一个元组
* **域（Domain）**：是一组具有相同数据类型的值的集合。属性的取值范围来自某个域。
* **分量**：元组中的一个属性值
* **关系模式**：对关系的描述，关系名（属性1，属性2，...，属性n）



> 关系必须是规范化的，满足一定的规范条件
>
> 最基本的规范条件：关系的每一个分量必须是一个**不可分的数据项**，不允许表中还有表



#### 4.1.2 关系模型的操作与完整性约束

* 数据操作（查询、插入、删除、更新）是集合操作，操作对象和操作结果都是关系
* 存取路径对用户隐蔽，用户只要指出“干什么”，不必详细说明“怎么干”
* 关系的完整性约束条件
	* 实体完整性
	* 参照完整性
	* 用户定义的完整性



#### 4.1.3 关系模型的优缺点

**优点**：

1. 建立在严格的数学概念的基础上
2. 概念单一：
	1. 实体和各类联系都用关系来表示
	2. 对数据的检索结果也是关系
3. 关系模型的存取路径对用户隐蔽
	1. 具有更高的数据独立性，更好的安全保密性
	2. 简化了程序员的工作和数据库开发建立的工作

**缺点**

1. 存取路径对用户隐蔽，查询效率往往不如格式化数据模型
2. 为提高性能，必须对用户查询请求进行优化，增加了开发DBMS的难度



### 4.2 NoSQL

* 基于 Key-Value 存储模型

* BigTable模型

	> 在关系模型的基础上加了第三个轴：时间轴，来记录时间变化过程中对表的更改

* 基于文档模型

* 基于图模型：记某个图为 $G(V,E)$，$V$ 为结点集合，每个结点具有若干属性， $E$ 为边集合，也可以具有若干属性



## 5 关系、关系模式和关系数据库

### 5.1 域（Domain）

域是一组具有相同数据类型的值的集合。例：

* 整数
* 实数
* 介于某个取值范围的整数
* 指定长度的字符串集合
* ...



### 5.2 笛卡尔积

* **笛卡尔积（Cartesian Product）**：给定一组域 $D_1, D_2, \dots, D_n$，允许其中某些域是相同的。

* $D_1, D_2, \dots, D_n$ 的笛卡尔积为

	> $D_1 \times D_2 \times \dots \times D_n = $
	>
	> {$(d_1, d_2, \dots, d_n) \| d_i \in D_i, i = 1, 2, 3, \dots, n$}

* 所有域的所有取值的一个组合

* 不能重复

* **元组（Tuple）**

	* 笛卡尔积中每一个元素（$d_1, d_2, \dots, d_n$） 叫做一格 $n$ 元组或简称元组

		>  例如：
		>
		> （张青梅，计算机专业，李勇）
		>
		> （张青梅，计算机专业，刘晨）

* **分量（Component）**

	* 笛卡尔积元素（$d_1, d_2, \dots, d_n$）中的每一个值 $d_i$ 叫做一格分量

		> 例如：张青梅，计算机专业，李勇，刘晨等

* **基数（Cardinal number）**

	* 若 $D_i(i = 1, 2, \dots, n)$ 为有限集，其基数为 $m_i(i = 1, 2, \dots, n)$，则 $D_1 \times D_2 \times \dots \times D_n$ 的基数 $M$ 为 $M = \prod_{i = 1}^{n} m_i$

* 笛卡尔积的表示方法

	* 笛卡尔积可表示为一张二维的表
	* 表中的每一行对应一个元组，表中的每列对应一个域

![](https://s2.loli.net/2022/02/22/gibYpmRlZHuPha8.png)



### 5.3 关系

**关系（Relation）**：$D_1 \times D_2 \times \dots \times D_n$ 的子集叫做在域 $D_1, D_2, \dots, D_n$ 上的关系， 表示为 $R(D_1, D_2, \dots, D_n)$

* $R$ ：关系名

* $n$ ：关系的**目**或**度（Degree）**

	> 当 $n = 1$ 时，成该关系为单元关系或一元关系
	>
	> 当 $n = 2$ 时，称该关系为二元关系



**元组**：关系中的每个元素是关系中的元组，通常用 $t$ 表示

**关系的表示**：关系也是一个二维表，表的每行对应一个元组，表的每列对应一个域

**属性**：

* 关系中不同列可以对应相同的域
* 为了加以区分，必须对每列起一个名字，称为**属性（Attribute）**
* $n$ 目关系必有 $n$ 个属性



#### 5.3.1 码

**候选码（Candidate Key）**

* 若关系中的某一属性**组**（即多个属性构成的组合）的值能唯一地标识一个元祖，则称该属性组为候选码
* 简单的情况：候选码只包含一个属性
* 最极端的情况：关系模式的所有属性组是这个关系模式的候选码，称为**全码（All-key）**



**主码**：若一个关系有多个候选码，则选定其中一个为**主码（Primary key）**

**主属性**：

* 候选码中的属性称为**主属性（Prime attribute）**
* 不包含在任何候选码中的属性称为非主属性或非码属性



#### 5.3.2 关系的类别

1. 基本关系（基本表或基表）：实际存在的表，是实际存储数据的逻辑表示
2. 查询表：查询结果对应的表
3. 视图表：由基本表或其他视图表导出的表，是**虚表**，不对应实际存储的数据



#### 5.3.3 基本关系的性质

1. 列是**同质（Homogeneous）**的：每一列中的分量是同一类型的数据，来自同一个域
2. 不同的列可出自同一个域：
	* 其中的每一列称为一个属性
	* 不同的属性要给予不同的属性名
3. 列的顺序无所谓：列的次序可以任意交换
4. 任意两个元组的候选码不能相同
5. 行的顺序无所谓：行（元组）的次序可以任意交换
6. 分量必须取原子值



### 5.4 关系模式

> **关系模式（Relation Schema）**是型，关系是值

关系模式是对关系的描述

* 元祖集合的结构：
	1. 属性组成
	2. 属性来自的域
	3. 属性与域之间的映像关系
* 完整性约束条件



* 关系模式可以形式化地表示为：$R(U,D,DOM,F)$

	> $R$ ：关系名
	>
	> $U$ ：组成该关系的属性名集合
	>
	> $D$ ：$U$ 中属性所来自的域
	>
	> $DOM$ ：属性向域的映像集合
	>
	> $F$ ：属性间数据的依赖关系的集合

* 关系模式通常可以简记为 $R(U)$ 或 $R(A_1,A_2, \dots, A_n)$

	* $R$ ：关系名

	* $A_1, A_2, \dots, A_n$ ：属性名

		> 注：域名及属性向域的映像常常直接说明为属性的类型，长度



#### 5.4.1 关系模式与关系

* 关系模式：

	1. 对关系的描述
	2. 静态的，稳定的

* 关系

	1. 关系模式在某一时刻的状态或内容
	2. 动态的、随时间不断变化的

* 关系模式和关系往往笼统称为关系

	> 通过上下文加以区别



### 5.5 关系数据库

关系数据库：在一个给定的应用领域中，所有关系的集合构成一个关系数据库

关系数据库的型与值：

* 关系数据库的型：关系数据库模式，是对关系数据库的描述
* 关系数据库的值：关系模式在**某一时刻**对应的关系的集合，通常称为关系数据库的值





## 6 关系的完整性

### 6.1 关系的三类完整性约束

1. 实体完整性
2. 参照完整性：关系模型必须满足的完整性约束条件称为关系的两个不变性（即1,2），应该由关系系统自动支持
3. 用户定义的完整性：应用领域需要遵循的约束条件，体现了具体领域中的语义约束



### 6.2 实体完整性

**实体完整性规则（Entity Integrity）**：若属性 $A$ 是基本关系 $R$ 的主属性，则属性 $A$ 不能取空值。

> 空值就是“不知道”或“不存在”或“无意义”的值
>
> 例：选修（学号，课程号，成绩）
>
> * “学号、课程号”为主码，则这两个属性都不能取空值



#### 6.2.1 实体完整性规则的说明

1. 实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集
2. 现实世界中的实体是可区分的，即它们具有某种唯一性标识。
3. 关系模型中以主码作为唯一性标识。
4. 主码中的属性即主属性不能取空值。

> 主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与第二点是矛盾的。



#### 6.2.2 关系间的引用

在关系模型中实体及实体间的联系都是用关系来描述的，自然存在着关系与关系间的引用。

> 例：学生实体、专业实体以及专业与学生间的一对多关系，学生关系引用了专业关系的主码“专业号”
>
> 学生（<u>学号</u>，姓名，性别，<span style='color: red'><u>专业号</u></span>，年龄）
>
> 专业（<span style='color: red'><u>专业号</u></span>，专业名）



#### 6.2.3 外码

* 设 $F$ 是基本关系 $R$ 的一个或一组属性，但不是关系 $R$ 的码。如果$F$ 与基本关系 $S$ 的主码 $K_s$ 相对应，则称 $F$ 是 $R$ 的外码（Foreign Key）

	* 基本关系 $R$ 称为参照关系（Referencing Relation）
	* 基本关系 $S$ 称为被参照关系（Referenced Relation）或目标关系（Target Relation）

* 其中：

	* 关系 $R$ 和 $S$ 不一定是不同的关系

	* 目标关系 $S$ 的主码$K_s$ 和参照关系的外码 $F$ 必须定义在同一个（或一组）域上

	* 外码并不一定要与相应的主码同名

		> 当外码与相应的主码属于不同关系时，往往取相同的名字，以便于识别

> 例：学生关系的“专业号”与专业关系的主码“专业号”相对应
>
> “专业号”属性是学生关系的外码
>
> 专业关系是被参照关系，学生关系为参照关系 



### 6.3 参照完整性规则

**参照完整性规则**：若属性（或属性组）$F$ 是基本关系 $R$ 的外码，且与基本关系 $S$ 的主码$K_s$ 相对应（基本关系 $R$ 和 $S$ 不一定是不同的关系），则对于 $R$ 中每个元组在 $F$ 上的值必须为：

* 或者取空值（$F$ 的每个属性值均为空值）
* 或者等于 $S$ 中某个元组的主码值

> 例：，学生关系中每个元组的“专业号”属性只取两类值：
>
> 1. 空值，表示尚未给该学生分配专业
>
> 2. 非空值，这时该值必须是专业关系中某个元组的“专业号”值，表示该学生不可能分配一个不存在的专业



### 6.4 用户定义的完整性

* 针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求

* 关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不需由应用程序承担这一功能

>  例：课程（课程号，课程名，学分）
>
> “课程名”属性必须取唯一值
>
> 非主属性“课程名”也不能取空值
>
> “学分”属性只能取值 { $1，2，3，4$ }



## 7 关系代数

### 7.1 基本的关系操作

**常用的关系操作**：

* 查询操作：选择、投影、连接、除、并、差、交、笛卡尔积

	>  选择、投影、并、差、笛卡尔积是5种基本操作

* 数据更新：插入、删除、修改

**关系操作的特点**：集合操作方式，操作的对象和结果都是集合，一次一集合的方式



* 关系代数是一种抽象的查询语言，它用对关系的运算来表达查询
* 关系代数
	* 运算对象是关系
	* 运算结果亦为关系
	* 关系代数的运算符有两类：集合运算符和专门的关系运算符
		* 传统的集合运算是从关系的“水平”方向即行的角度进行
		* 专门的关系运算不仅涉及行而且涉及列

![](https://s2.loli.net/2022/02/22/ogQ6sWkX1ATfvHE.png)



### 7.2 并

**并（Union）**：

1. $R$ 和 $S$ 具有相同的目 $n$（即两个关系都有 $n$ 个属性），且相应的属性取自同一个域
2. $R \cup S$ 仍为 $n$ 目关系，由属于 $R$ 或属于 $S$ 的元组组成
3. $R \cup S = \left \{ t \| t \in R \lor t \in S \right \}$

![](https://s2.loli.net/2022/02/22/AZmkQLswxWGt2C7.png)



### 7.3 差

**差（Difference）**：

1. $R$ 和 $S$ 具有相同的目 $n$ ，且相应的属性取自同一个域

2. $R - S$ 仍为 $n$ 目关系，由属于 $R$ 而不属于 $S$ 的所有元组组成

3. $R -S = \left \{ t \|t \in R \wedge t \notin S \right \}$

![](https://s2.loli.net/2022/02/23/ogDZdabWmFsr1Ni.png)



### 7.4 交

**交（Intersection）**：

1. $R$ 和 $S$ 具有相同的目 $n$ ，且相应的属性取自同一个域

2. $R \cap S$ 仍为 $n$ 目关系，由既属于 $R$ 又属于 $S$ 的元组组成

3. $R \cap S = \left \{ t \| t \in R \land t \in S \right \}$

4. $R \cap S = R – (R - S)$

![](https://s2.loli.net/2022/02/23/TxAIvauSq7w1nbl.png)



### 7.5 笛卡尔积

>严格来讲应该是广义的笛卡尔积（Extended Cartesian Product）

1. $R$: $n$ 目关系，$k_1$ 个元组，$S$: $m$ 目关系，$k_2$ 个元组

2. $R \times S$： 
	1. 列：$(n + m)$ 列元组的集合
		* 元组的前 $n$ 列是关系 $R$ 的一个元组
		* 后 $m$ 列是关系 $S$ 的一个元组
	2. 行：$k_1 \times k_2$ 个元组
		* $R \times S = \left \{t_r, t_s \|t_r \in R \land t_s \in S \right \}$

![image-20220223200700591](C:/Users/Zyi/AppData/Roaming/Typora/typora-user-images/image-20220223200700591.png)



### 7.6 使用的记号

#### 7.6.1 元组的连接

![](https://s2.loli.net/2022/02/23/lkymY65irK3wFG7.png)

1. $R$ 为 $n$ 目关系，$S$ 为 $m$ 目关系。

2. $t_r \in R,t_s \in S$，称为元组的连接。

3. 元组的连接是一个 $n + m$ 列的元组，前 $n$ 个分量为 $R$ 中的一个 $n$ 元组，后 $m$ 个分量为 $S$ 中的一个 $m$ 元组。 



#### 7.6.2 象集

1. 给定一个关系 $R(X，Z)$，$X$ 和 $Z$ 为属性组。

2. 当 $t[X]=x$ 时，$x$ 在 $R$ 中的象集（Images Set）为：
	1. $Z_x =\left \{t[Z] \|t \in R, t[X]=x \right \}$
	2. 它表示 $R$ 中属性组 $X$ 上值为 $x$ 的诸元组在 $Z$ 上分量的集合

![](https://s2.loli.net/2022/02/23/Ois7x582K1aNuGF.png)

 

### 7.7 选择

> 选择（Selection）又称为限制（Restriction）

选择运算符的含义：

* 在关系 $R$ 中选择满足给定条件的所有元组
* $\sigma_F(R) = \left \{t \| t \in R \land F(t)= true \right \}$
* $F$：选择条件，是一个逻辑表达式，取值为“真”或“假”
	* 基本形式为：$X_1 \theta Y_1$，$\theta$ 表示比较运算符，它可以是$＞, \ge,＜, \le, ＝, \ne$
	* 在基本的选择条件上可以进一步进行逻辑运算（与，或，非）

![](https://s2.loli.net/2022/02/23/TNROxyeCmKL3b7A.png)



### 7.8 投影

**投影（Projection）**：

* 从 $R$ 中选择出若干属性列组成新的关系

* $\pi_A(R) = \left \{ t[A] \| t \in R \right \}$

	>  $A$：$R$ 中的属性列 

* 投影之后不仅取消了原关系中的某些列，而且还可能取消某些元组（避免重复行）

![](https://s2.loli.net/2022/02/23/rOwcIUYNDFlxTMV.png)



### 7.9 连接

> 连接（Join）也称为 $\theta$ 连接

* 连接运算的含义：从两个关系的笛卡尔积中选取属性间满足一定条件的元组。
* $R \Join  S = \left \{ \overline{t_r t_s} \| t_r \in R \land t_s \in S \land t_r[A] \theta t_s[B]  \right \}$
	* $A,B$：分别为 $R$ 和 $S$ 上度数相等且可比的属性组
	* $\theta$ ：比较运算符
* 连接运算从 $R$ 和 $S$ 的广义笛卡尔积 $R \times S$ 中选取 $R$ 关系在 $A$ 属性组上的值与 $S$ 关系在 $B$ 属性组上的值满足比较关系θ的元组 



#### 7.9.1 等值连接

* $\theta$ 为“＝”的连接运算称为等值连接
* 从关系 $R$ 与 $S$ 的广义笛卡尔积中选取 $A$、$B$ 属性值相等的那些元组，即等值连接为：
* $R \Join  S = \left \{ \overline{t_r t_s} \| t_r \in R \land t_s \in S \land t_r[A] = t_s[B]  \right \}$



#### 7.9.2 自然连接

> 一种特殊的等值连接

* 两个关系中进行比较的分量必须是相同的属性组

* 在结果中把重复的属性列去掉

* 自然连接的含义：$R$ 和 $S$ 具有相同的属性组 $B$
	* $R \Join  S = \left \{ \overline{t_r t_s}[U-B] \| t_r \in R \land t_s \in S \land t_r[B] = t_s[B]  \right \}$

![](https://s2.loli.net/2022/02/23/T9q2mzNK7MnB4sl.png)



#### 7.9.3 悬浮元组

两个关系 $R$ 和 $S$ 在做自然连接时，关系 $R$ 中某些元组有可能在 $S$ 中不存在公共属性上值相等的元组，从而造成 $R$ 中这些元组在操作时被舍弃了，这些被舍弃的元组称为悬浮元组。



#### 7.9.4 外连接

> Outer Join

* 如果把悬浮元组也保存在结果关系中，而在其他属性上填空值(Null)，就叫做外连接

* 左外连接(LEFT OUTER JOIN或LEFT JOIN)：只保留左边关系 $R$ 中的悬浮元组

* 右外连接(RIGHT OUTER JOIN或RIGHT JOIN)：只保留右边关系 $S$ 中的悬浮元组



### 7.10 除运算

* 给定关系 $R (X, Y)$ 和 $S (Y, Z)$，其中 $X, Y, Z$ 为属性组。

* $R$ 中的 $Y$ 与 $S$ 中的 $Y$ 可以有不同的属性名，但必须出自相同的域集。

* $R$ 与 $S$ 的除运算得到一个新的关系 $P(X)$，$P$ 是 $R$ 中满足下列条件的元组在 $X$ 属性列上的投影：

	* 元组在 $X$ 上分量值 $x$ 的象集 $Y_x$ 包含 $S$ 在 $Y$ 上投影的集合，记作：

	* $R \div S = \left \{t_r[X] \| t_r \in R \land \pi_Y(S) \subseteq Y_x \right \}$

		> $Y_x$：$x$ 在 $R$ 中的象集，$x = t_r[x]$ 

![](https://s2.loli.net/2022/02/23/nl3uWkzC8JSTaRI.png)



## 8 SQL概述

### 8.1 什么是SQL

* **SQL（Structured Query Language）结构化查询语言**，是关系数据库的标准语言

* SQL是一个通用的、功能极强的关系数据库语言
	* 综合统一
	* 高度非过程化
	* 面向集合的操作方式
	* 以同一种语法结构提供两种使用方法
	* 语言简洁，易学易用

> 注意，SQL只是一种规范性的语言，但是在不同的数据库管理系统中，语法可能会有所不同，比如在MySQL中的语法和在Oracle中的语法可能就有所不同。



### 8.2 SQL的特点



#### 8.2.1 综合统一

* 集数据定义语言（DDL），数据操纵语言（DML），数据控制语言（DCL）功能于一体。
* 可以独立完成数据库生命周期中的全部活动：
	* 定义和修改、删除关系模式，定义和删除视图，插入数据，建立数据库;
	* 对数据库中的数据进行查询和更新;
	* 数据库重构和维护
	* 数据库安全性、完整性控制，以及事务控制
	* 嵌入式SQL和动态SQL定义

* 用户数据库投入运行后，可根据需要随时逐步修改模式，不影响数据库的运行。
* 数据操作符统一



#### 8.2.2 高度非过程化

* 非关系数据模型的数据操纵语言“面向过程”，必须指定存取路径。
* SQL只要提出“做什么”，无须了解存取路径。
* 存取路径的选择以及SQL的操作过程由系统自动完成。



#### 8.2.3 面向集合的操作方式

* 非关系数据模型采用面向记录的操作方式，操作对象是一条记录
* SQL采用集合操作方式（<span style='color: red'>**无序，取出的顺序由DBMS决定**</span>）
	* 操作对象、查找结果可以是元组的集合
	* 一次插入、删除、更新操作的对象可以是元组的集合



#### 8.2.4 以同一种语法结构提供多种适用方式

* SQL是独立的语言，能够独立地用于联机交互的使用方式
* SQL又是嵌入式语言，能够嵌入到高级语言（例如C，C++，Java）程序中，供程序员设计程序时使用



#### 8.2.5 语言简洁，易学易用

* SQL功能极强，完成核心功能只用了9个动词:
	* 数据定义：CREATE，DROP，ALTER
	* 数据查询：SELECT
	* 数据操作：INSERT，UPDATE，DELETE
	* 数据控制：GRANT，REVOKE



### 8.3 SQL与关系数据库三级模式

![](https://s2.loli.net/2022/03/01/Tq76fwv9OXnlcHS.png)

#### 8.3.1 基本表

* 本身独立存在的表

* 一个关系对应一个基本表

* 一个（或多个）基本表对应一个存储文件

* 一个表可以带若干索引

#### 8.3.2 存储文件

* 逻辑结构组成了关系数据库的内模式
* 物理结构对用户是隐蔽的

#### 8.3.3 视图

* 从一个或几个基本表中导出的表
* 数据库中只存放视图的定义而不存放试图对应的数据
* 视图是一个**虚表**
* 用户可以在视图上再定义视图





## 9 SQL数据定义

**层次化的数据库对象命名机制**

* 一个关系数据库管理系统的实例（instance）中可以建立多个数据库

* 一个数据库中可以建立多个模式

	> 在`MySQL`中，一个数据库只对应一个模式，即"database"和“schema”两个词是同义的

* 一个模式下通常包括多个表、视图和索引等数据库对象。



> 接下来是SQL基本的增删改查语句用法，这里省略

## 10 SQL 中的空值

> 空值一般有以下几种情况：
>
> 1. 该属性应该有一个值，但目前还不知道它的具体值
> 2. 该属性不该有值
> 3. 由于某种原因不便于填写

对于空值的判断 用 `IS NULL` 或 `IS NOT NULL` 来判断

例：从Student表中找出漏填了数据的学生信息

```mysql
SELECT *
FROM `Student`
WHERE `Sname` IS NULL OR `Ssex` IS NULL OR `Sage` IS NULL OR `Sdept` IS NULL;
```

* 属性定义（或者域定义）中：
	* 有 `NOT NULL` 约束条件的不能取空值
	* 加了 `UNIQUE` 限制的属性不能取空值
	* 码属性不能取空值

### 10.1 空值的运算

* 空值与另一个值（包括另一个空值）的算术运算的结果为空值
* 空值与另一个值（包括另一个空值）的比较运算结果为`UNKNOWN`。
* 传统二值（`TRUE`、`FALSE`）因为 `UNKNOWN` 的扩展成了三值逻辑。

|  x   |  y   | x AND y | x OR y | NOT X |
| :--: | :--: | :-----: | :----: | :---: |
|  T   |  T   |    T    |   T    |   T   |
|  T   |  U   |    U    |   T    |   F   |
|  T   |  F   |    F    |   T    |   F   |
|  U   |  T   |    U    |   T    |   U   |
|  U   |  U   |    U    |   U    |   U   |
|  U   |  F   |    F    |   U    |   U   |
|  F   |  T   |    F    |   T    |   T   |
|  F   |  U   |    F    |   U    |   T   |
|  F   |  F   |    F    |   F    |   F   |



## 11 视图

视图的特点：

1. 虚表，是从一个或几个基本表（或视图）导出的表
2. 只存放视图的定义，不存放视图对应的数据
3. 基表中的数据发生变化，从视图中查询出的数据也随之改变。

### 11.1 建立视图

```MYSQL
CREATE VIEW <视图名> [(<列名>...)]
AS <子查询>
[WITH CHECK OPTION]
```

* `WITH CHECK OPTION`：对树突进行 `UPDATE` 、`INSERT`、`DELETE` 操作时要保证更新、插入或删除的行满足视图定义中的谓词条件（即子查询中的条件表达式）。
* 子查询可以是任意的 `SELECT` 语句，是否可以含有 `ORDER BY` 子句和 `DISTINCT` 短语，则决定于具体系统的实现。
* 组成视图的属性列明：全部省略或全部指定
	1. 全部省略：由子查询中 `SELECT` 目标列中的诸字段组成
	2. 明确指定视图的所有列名：
		1. 某个目标列是聚集函数或列表达式
		2. 多表连接时选出了几个同名列作为视图的字段
		3. 需要在视图中为某个列启用新的更合适的名字
* 关系数据库管理系统执行 `CREATE VIEW` 语句时只是把视图定义存入数据字典，并不执行其中的 `SELECT` 语句。
* 在对视图查询时，按视图的定义从基本表中将数据查出。

例：建立信息系学生的视图。

```MYSQL
CREATE VIEW IS_Student
AS  SELEECT Sno, Sname, Sage
	FROM Student
	WHERE Sdept = 'IS';
```

>若一个视图是从单个基本表导出的，并且只是去掉了基本表的某些行和某些列，但保留了主码，我们称这类视图为**行列子集视图**。

<span style = 'color: red'>注意点：</span>

* 可以在视图之上建立视图

* 可以基于多个基表建立视图

* 可以建立分组视图

	将学生的学号及平均成绩定义为一个视图

	```MYSQL
	CREATE VIEW student_grade(Sno, Gavg)
	AS  SELECT Sno, AVG(Grade)
		FROM SC
		GROUP BY Sno;
	```

### 11.2 删除视图

```mysql
DROP VIEW <视图名> [CASCADE]
```

* 该语句从数据字典中删除指定的视图定义
* 如果该视图上还导出了其他视图，使用CASCADE级联删除语句，把该视图和由它导出的所有视图一起删除
* 删除基表时，由该基表导出的所有视图定义都必须**显式**地使用DROP VIEW语句删除

### 11.3 查询视图

* 用户角度：查询视图与查询基本表相同
* 关系数据库管理系统实现视图查询的方法
	* 视图消解法（View Resolution）
	* 进行有效性检查
	* 转换成等价的对基本表的查询
	* 执行修正后的查询

> 视图消解法并不一定能够生成正确的查询，在使用了聚集函数的情况下，比如`AVG()`，就并不一定能够正确的生成出查询对应基表的 `SELECT` 表达式。



### 11.4 更新视图

* 允许对行列子集视图进行更新

* 对其他类型视图的更新不同系统有不同限制

* 更新视图的限制：一些视图是不可更新的，因为对这些视图的更新不能**唯一地有意义**地转换成对相应基本表的更新

	> 比如更新一列通过 `AVG()` 获得的视图的列，是没办法对原表进行更新操作的

* 一个不允许更新的视图上定义的视图也不允许更新

### 11.5 视图的作用

* 当视图中数据不是直接来自基本表时，定义视图能够简化用户的操作
	* 基于多张表连接形成的视图
	* 基于复杂嵌套查询的视图
	* 含导出属性的视图
* 视图机制能使不同用户以不同方式看待同一数据，
* 适应数据库共享的需要



## 12 数据库安全性

数据库的不安全因素：

* 非授权用户对数据库的恶意存取和破坏
* 数据库中重要或敏感的数据被泄漏
* 安全环境的脆弱性

| 安全级别 |                       定义                        |
| :------: | :-----------------------------------------------: |
|    A1    |            验证设计（Verified Design）            |
|    B3    |            安全域（Security Domains）             |
|    B2    |        结构化保护（Structural Protection）        |
|    B1    |    标记安全保护（Labeled Security Protection）    |
|    C2    |  受控的存取保护（Controlled Access Protection）   |
|    C1    | 自主安全保护（Discretionary Security Protection） |
|    D     |          最小保护（Minimal Protection）           |

* D级：将一切不符合更高标准的系统均归于D组
* C1级：
	1. 非常初级的自主安全保护
	2. 能够实现对用户和数据的分离，进行自主存取控制（DAC），保护或限制用户权限的传播。
	3. 现有的商业系统稍作改进即可满足
* C2级：
	1. 安全产品的最低档次
	2. 提供受控的存取保护，将C1级的DAC进一步细化，以个人身份注册负责，并实施审计和资源隔离
	3. 达到C2级的产品在其名称中往往不突出“安全”（Security）这一特色
* B1级：
	1. 标记安全保护。“安全”（Security）或“可信的”（Trusted）产品。
	2. 对系统的数据加以标记，对标记的主体和客体实施强制存取控制（MAC）、审计等安全机制
* B2级：
	1. 结构化保护
	2. 建立形式化的安全策略模型并对系统内的所有主体和客体实施DAC和MAC
* B3级：
	1. 安全域
	2. 该级的TCB必须满足访问监控器的要求，审计跟踪能力更强，并提供系统恢复过程
* A1级：验证设计，即提供B3级保护的同时给出系统的形式化设计说明和验证以确信各安全保护真正实现。



### 12.1 存取控制

* 存取控制机制组成
	* 定义用户权限，并将用户权限登记到数据字典中
		* 用户对某一数据对象的操作权力称为权限
		* DBMS提供适当的语言来定义用户权限，存放在数据字典中，称做安全规则或授权规则
	* 合法权限检查
		* 用户发出存取数据库操作请求
		* DBMS查找数据字典，进行合法权限检查
* 用户权限定义和合法权检查机制一起组成了数据库管理系统的存取控制子系统



**自主存取控制（Discretionary Access Control, DAC）**

* C2级
* 用户对不同的数据对象有不同的存取权限
* 不同的用户对同一对象也有不同的权限
* 用户还可将其拥有的存取权限转授给其他用户

**强制存取控制（Mandatory Access Control, MAC）**

* B1级
* 每一个数据对象被标以一定的密级
* 每一个用户也被授予某一个级别的许可证
* 对于任意一个对象，只有具有合法许可证的用户才可以存取

#### 12.1.1 自主存取控制方法

> 通过 SQL 的 `GRANT` 语句和 `REVOKE` 语句实现

* 用户权限组成：

	* 数据对象

	* 操作类型

* 定义用户存取权限：定义用户可以在哪些数据库对象上进行哪些类型的操作
* 定义存取权限称为授权

<span style='color: red'>**SQL中的授权机制**</span>

1. 数据库管理员：
	* 拥有所有对象的所有权限
	* 根据实际情况不同的权限授予不同的用户
2. 用户：
	* 拥有自己建立的对象的全部的操作权限
	* 可以使用GRANT，把权限授予其他用户
3. 被授权的用户
	* 如果具有“继续授权”的许可，可以把获得的权限再授予其他用户
	* 所有授予出去的权力在必要时又都可用REVOKE语句收回

#### 12.1.2 GRANT

```MYSQL
GRANT <权限>[, <权限>]...
ON <对象类型> <对象名> [, <对象类型> <对象名>]...
TO <用户> [, <用户>]...
[WITH GRANT OPTION]
```

> 这里的对象类型在SQL中指：视图、表、属性列（必须指定列名）等
>
> 权限：`ALL PRIVILIGES` 代表所有权限，其他还包括 `SELECT` 等
>
> 用户：`PUBLIC` 表示给所有用户，其他指定用户名
>
> 语义：将对指定操作对象的指定操作权限授予指定的用户

**WITH GRANT OPTION**子句：

* 指定：该用户可以再授予别人权限
* 没有指定：不能传播

> 不允许循环授权



#### 12.1.3 REVOKE

```MYSQL
REVOKE <权限> [, <权限>]...
ON <对象类型> <对象名> [, <对象类型> <对象名>]...
FROM <用户> [, <用户>]...
[CASCADE | RESTRICT]
```

> `CASCADE`：级联回收，即回收一个用户的权限时，该用户授权的所有用户的该权限都会被回收。
>
> 例：U5 给予了 U6 `SELECT` 的权限，在回收 U5 的 `SELECT` 权限的时候，U6 的 `SELECT` 权限也会被回收。（但如果 U6 从别的用户那里也得到过 `SELECT` 权限，则 U6 仍然具有该权限）
>
> `RESTRICT`：与上述相反，非级联的回收



#### 12.1.4 创建数据库模式的权限

```sql
CREATE USER <username> 
[WITH] [DBA | RESOURCE | CONNECT]
```

> 注：`CREATE USER`不是 `SQL` 标准，各个系统的实现相差甚远。

1. CONNECT：如没有指定创建的新用户的权限，默认该用户拥有CONNECT权限。拥有CONNECT权限的用户不能创建新用户，不能创建模式，也不能创建基本表，只能登录数据库
2. RESOURCE：拥有RESOURCE权限的用户能创建基本表和视图，成为所创建对象的属主。但不能创建模式，不能创建新的用户
3. DBA：拥有DBA权限的用户是系统中的超级用户，可以创建新的用户、创建模式、创建基本表和视图等；DBA拥有对所有数据库对象的存取权限，还可以把这些权限授予一般用户



#### 12.1.5 强制存取控制

* 保证更高程度的安全性
* 用户不能直接感知或进行控制
* 适用于对数据有严格而固定密级分类的部门

在强制存取控制中，数据库管理系统所管理的全部实体被分为**主体**和**客体**两大类。

* 主体是系统中的活动实体
	* 数据库管理系统所管理的实际用户
	* 代表用户的各进程
* 客体是系统中的被动实体，受主体操纵
	* 文件、基本表、索引、视图



**强制存取控制规则**：

* 仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体
* 仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体

强制存取控制（MAC）是对数据本身进行密级标记，无论数据如何复制，标记与数据是一个不可分的整体，只有符合密级标记要求的用户才可以操纵数据。



## 13 数据库完整性

* 数据库的正确性：是指数据时符合现实世界语义，反映了当前实际状况的。
* 数据的相容性：是指数据库同一对象在不同关系表中的数据时符合逻辑的。

### 13.1 完整性 vs 安全性

> 数据的完整性和安全性是两个不同概念

* 数据的完整性：
	* 防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据
	* 防范对象：不合语义的、不正确的数据
* 数据的安全性
	* 保护数据库，防止恶意的破坏和非法的存取
	* 防范对象：非法用户和非法操作

### 13.2 完整性机制

* 提供定义完整性约束条件的机制
	* 完整性约束条件也称为完整性规则，是数据库中的数据必须满足的语义约束条件
	* SQL标准使用了一系列概念来描述完整性，包括关系模型的实体完整性、参照完整性和用户定义完整性
	* 这些完整性一般由SQL的数据定义语言语句来实现
* 提供完整性检查的方法
	* 数据库管理系统中检查数据是否满足完整性约束条件的机制称为完整性检查。
	* 一般在INSERT、UPDATE、DELETE语句执行后开始检查，也可以在事务提交时检查
* 违约处理
	* 数据库管理系统若发现用户的操作违背了完整性约束条件，就采取一定的动作
		* 拒绝（NO ACTION）执行该操作
		* 级连（CASCADE）执行其他操作

> 当然，也可以在应用程序的层面来实现完整性的约束，比如用Java来实现完整性的约束和检查。

### 13.3 实体完整性

* 完整模型的实体完整性：`CREATE TABLE` 中用 `PRIMARY KEY` 定义
* 单属性构成的码有两种说明方法：
	* 定义为列级约束条件
	* 定义为表级约束条件
* 对多个属性构成的码只有一种说明方法：定义为表级约束条件。

例：

单属性我们可以用以下两种方式来定义其为主码

```MYSQL
CREATE TABLE `user`
(
    `user_id`	BIGINT NOT NULL AUTO_INCREAMENT PRIMARY KEY
) ENGINE = InnoDB CHARSET = utf8;
```

```MYSQL
CREATE TABLE `user`
(
    `user_id`	BIGINT NOT NULL AUTO_INCREAMENT,
    CONSTRAINT PRIMARY KEY (`user_id`)
) ENGINE = InnoDB CHARSET = utf8;
```

对于多属性，只能用下面这种方法来定义主码。

**实体完整性检查和违约处理**

插入或对主码列进行更新操作时，关系数据库管理系统按照实体完整性规则自动进行检查。包括：

* 检查主码值是否唯一，如果不唯一则拒绝插入或修改
* 检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改

> 如何实现这种检查是否唯一的方法，如果进行全表扫描，在数据十分多的情况下是十分耗时的，因此，DBMS一般都会在主码上建立索引，比如用B+树索引来减少DBMS检查主码是否唯一时间。



### 13.4 参照完整性

* 关系模型的参照完整性定义
	* 在`CREATE TABLE` 中用 `FOREIGN KEY` 短语定义哪些列为外码
	* 在 `REFERENCES` 短语指明这些外码参照哪些表的主码。

例：

```MYSQL
CREATE TABLE `user`
(
    `user_id` BIGINT NOT NULL AUTO_INCREAMENT,
    `user_no` BIGINT NOT NULL,
    CONSTRAINT PRIMARY KEY (`user_id`),
    CONSTRAINT FOREIGN KEY (`user_no`) REFERENCES `Course`(`user_no`)
)
```

* 一个参照完整性将两个表中的相应元组联系起来
* 对被参照表和参照表进行增删改操作时有可能破坏参照完整性，必须进行检查

**参照完整性违约处理**

* 拒绝（NO ACTION）执行：不允许该操作执行。该策略一般设置为默认策略
* 级联（CASCADE）操作：当删除或修改被参照表的一个元组造成了与参照表的不一致，则删除或修改参照表中的所有造成不一致的元组
* 设置为空值（SET-NULL）
	* 当删除或修改被参照表的一个元组时造成了不一致，则将参照表中的所有造成不一致的元组的对应属性设置为空值。
	* 对于参照完整性，除了应该定义外码，还应定义外码列是否允许空值

> 参照完整性一般会在程序层面来进行定义，而不会给数据库中直接添加外键，因为外键的删除和插入都涉及到太过复杂的关系。



### 13.5 用户定义的完整性

* 用户定义的完整性是：针对某一具体应用的数据必须满足的语
	义要求
	* 属性上的约束条件
	* 元组上的约束条件
		* 同属性值限制相比，元组级的限制可以设置不同属性之间的取值的相互约束条件
* 关系数据库管理系统提供了定义和检验用户定义完整性的机制，不必由应用程序承担
	* 插入元组或修改属性的值时，关系数据库管理系统检查约束条件是否被满足
	* 如果不满足则操作被拒绝执行

`CHECK()`语句可以自定义完整性。

**完整性约束命名子句**

* 创建完整性约束
	* 完整性约束命名子句
		* CONSTRAINT <完整性约束条件名><完整性约束条件>
		* <完整性约束条件>包括NOT NULL、UNIQUE、PRIMARY KEY短语、FOREIGN KEY短语、CHECK短语等
* 修改完整性约束
	* 使用ALTER TABLE语句修改表中的完整性限制



## 14 断言

* 创建断言的语句格式：

	```sql
	CREATE ASSERTION <断言名> <CHECK 子句>
	```

	* 每个断言都被赋予一个名字， `<CHECK 子句>` 中的约束条件与 `WHERE` 子句的表达式类似

* 删除断言的语句格式为

	```mysql
	DROP ASSERTION <断言名>;
	```



## 15 触发器

* 触发器（Trigger）是用户定义在关系表上的一类由事件驱动的特殊过程
	* 触发器保存在数据库服务器中
	* 任何用户对表的增、删、改操作均由服务器自动激活相应的触发器
	* 触发器可以实施更为复杂的检查和操作，具有更精
		细和更强大的数据控制能力
* 不同的RDBMS产品触发器语法各不相同

### 15.1 定义触发器

```MYSQL
CREATE TRIGGER <触发器名>
[BEFORE | AFTER] <触发事件> ON <表名>
REFERENCING NEW | OLD ROW AS <变量>
FOR EACH [ROW | STATEMENT]
[WHEN <触发条件>] <触发动作体>
```

* 触发器又叫做事件-条件-动作（event-condition-action）规则。
	* 当特定的系统事件发生时，对规则的条件进行检查，如果条件成立则执行规则中的动作，否则不执行该动作。规则中的动作体可以很复杂，通常是一段SQL存储过程。

### 15.2 删除触发器

```mysql
DROP TRIGGER <触发器名> ON <表名>
```

触发器必须是一个已经创建的触发器，并且只能由具有相应权限的用户删除。



## 16 关系模式及范式

关系模式由五部分组成，是一个五元组：
$$
R(U, D, DOM,F)
$$

* 关系名 $R$ 是符号化的元组语义
* $U$ 为一组属性
* $D$ 为属性组 $U$ 中的属性所来自的域
* $DOM$ 为属性到域的映射
* $F$ 为属性组 $U$ 上的一组数据依赖

> 由于 $D$、$DOM$ 与模式设计关系不大，因此可以把关系模式看作一个三元组：$R<U, F>$
>
> * 当且仅当 $U$ 上的一个关系 $r$ 满足 $F$ 时，$r$ 称为关系模式 $R<U, F>$ 的一个关系
> * 作为二维表，关系要符合一个最基本的条件：每个分量必须是不可分开地数据项。满足了这个条件的关系模式就属于**第一范式（1NF）**

范式的种类：

1. 第一范式（1NF）
2. 第二范式（2NF）
3. 第三范式（3NF）
4. BC范式（BCNF）
5. 第四范式（4NF）
6. 第五范式（5NF）

![](https://s2.loli.net/2022/04/27/v6u2CaDPhLAKsk7.png)

### 16.1 数据依赖

* 是一个关系内部属性与属性之间的一种约束关系：通过属性间值的相等与否体现出来的数据间相关联系
* 是现实世界属性间相互联系的抽象
* 是数据内在的性质
* 是语义的体现

数据依赖的主要类型：

1. 函数依赖（Functional Dependency, FD）
2. 多值依赖（Multi-Valued Dependency, MVD）

### 16.2 1NF

每个分量必须是不可分开地数据项。满足了这个条件的关系模式就属于**第一范式（1NF）**

![](https://s2.loli.net/2022/04/27/iuheKFoscrDnXLU.png)

第一范式的问题：

1. 数据冗余：浪费大量的存储空间。

	>  每一个系主任的姓名重复出现，重复次数与该系所有学生的所有课程成绩出现次数相同。

2. 更新异常（Update Anomalies）：数据冗余，更新数据时，维护数据完整性代价大。

	> 某系更换系主任后，必须修改与该系学生有关的每一个元组。

3. 插入异常（Insertion Anomalies）

	> 如果一个系刚成立，尚无学生，则无法把这个系及其系主任的信息存入数据库。

4. 删除异常（Deletion Anomalies）

	> 如果某个系的学生全部毕业了，则在删除该系学生信息的同时，把这个系及其系主任的信息也丢掉了。



### 16.3 函数依赖与码

定义6.1 设 $R(U)$ 是一个属性集 $U$ 上的关系模式，$X$ 和 $Y$ 是 $U$ 的子集。若对于 $R(U)$ 的任意一个可能的关系 $r$，$r$ 中不可能存在两个元组在 $X$ 上的属性值相等， 而在 $Y$ 上的属性值不等， 则称 “$X$ 函数确定$Y$ ”或“ $Y$ 函数依赖于$X$ ”，记作 $X \rightarrow Y$，$X$ 称为这个函数依赖的决定因素（Determinant）。

* 函数依赖不是指关系模式 $R$ 的某个或某些关系实例满足的约束条件，而是指 $R$ 的所有关系实例均要满足的约束条件。
* 函数依赖是语义范畴的概念。只能根据数据的语义来确定函数依赖。
	* 例如“姓名→年龄”这个函数依赖只有在不允许有同名人的条件下成立
* 数据库设计者可以对现实世界作强制的规定。例如规定不允许同名人出现，函数依赖“姓名→年龄”成立。所插入的元组必须满足规定的函数依赖，若发现有同名人存在， 则拒绝装入该元组。

#### 16.3.1 平凡函数依赖于非平凡函数依赖

在关系模式 $R(U)$ 中，对于 $U$ 的子集 $X$ 和 $Y$，

* 如果 $X \rightarrow Y$，但 $Y \notin X$，则称 $X \rightarrow Y$是非平凡的函数依赖
* 若 $X \rightarrow Y$，但 $Y \in X$ , 则称 $X \rightarrow Y$ 是平凡的函数依赖

例：在关系`SC(Sno, Cno, Grade)`中

* 非平凡函数依赖：`(Sno, Cno) -> Grade`
* 平凡函数依赖：
	1. `(Sno, Cno) -> Sno`
	2. `(Sno, Cno) -> Cno`

对于任一的关系模式，平凡函数依赖都是必然成立的，它不反应新的语义，因此若不特别声明，我们总是讨论非平凡函数依赖。

#### 16.3.2 完全函数依赖与部分函数依赖

![](https://s2.loli.net/2022/04/27/L92GVYgEZAKIvjy.png)

#### 16.3.3 传递函数依赖

![](https://s2.loli.net/2022/04/27/GcZ36azoBU2yWJk.png)

### 16.4 2NF

定义：若关系模式 $R \in 1NF$，并且每一个非主属性都完全函数依赖于任何一个候选码，则 $R \in 2NF$。

一个关系如果不属于2NF，那么会出现以下的问题：

1. 插入异常
2. 删除异常
3. 修改复杂

### 16.5 3NF

定义：设关系模式 $R<U, F> \in 1NF$，若 $R$ 中不存在这样的码 $X$、属性组 $Y$ 及非主属性 $Z (Y \notin Z)$，使得 $X \rightarrow Y$， $Y \rightarrow Z$ 成立， $Y \not \rightarrow X$ 不成立，则称 $R<U, F> \in 3NF$。

### 16.6 BCNF

定义：设关系模式 $R<U,F> \in 1NF$，若 $X \rightarrow Y$ 且 $Y \notin X$ 时 $X$ 必含有码，则 $R<U,F> \in BCNF$。

BCNF的关系模式所具有的性质

* 所有非主属性都完全函数依赖于每个候选码
* 所有主属性都完全函数依赖于每个不包含它的候选码
* 没有任何属性完全函数依赖于非码的任何一组属性

### 16.7 多值依赖与4NF

**多值依赖**的定义：设 $R(U)$ 是属性集 $U$ 上的一个关系模式。$X,Y,Z$ 是 $U$ 的子集，并且 $Z=U-X-Y$ 。关系模式 $R(U)$ 中多值依赖$X \rightarrow \rightarrow Y$成立，当且仅当对 $R(U)$ 的任一关系 $r$ ，给定的一对 $(x,z)$值，有一组 $Y$ 的值，这组值仅仅决定于 $x$ 值而与 $z$ 值无关。

* 平凡多值依赖：若 $X \rightarrow \rightarrow Y$ ，而 $Z = \Phi$ ，即 $Z$ 为空，则称 $X \rightarrow \rightarrow Y$ 为平凡的多值依赖
* 否则成 $X \rightarrow \rightarrow Y$ 为非平凡的多值依赖

**多值依赖的性质**

1. 多值依赖具有对称性：即若 $X \rightarrow \rightarrow Y$ ，则 $X \rightarrow \rightarrow Z$ ，其中 $Z = U - X - Y$。
	* 多值依赖的对称性可以用完全二分图直观地表示出来
2. 多值依赖具有传递性：即若 $X \rightarrow \rightarrow Y$ , $Y \rightarrow \rightarrow Z$ , 则 $X \rightarrow \rightarrow Z - Y$ 
3. 函数依赖是多值依赖的特殊情况：即若 $X \rightarrow Y$，则 $X \rightarrow \rightarrow Y$

**4NF的定义**：关系模式 $R<U,F> \in 1NF$ ，如果对于 $R$ 的每个非平凡多值依赖 $X \rightarrow \rightarrow Y（Y \notin X）$，$X$ 都含有码，则 $R<U,F> \in 4NF$。

* 4NF就是限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。4NF所允许的非平凡多值依赖实际上是函数依赖。
* 如果一个关系模式是4NF，则必为BCNF。



## 17 数据库设计概述

> 数据库设计是指对于一个给定的应用环境，构造（设计）优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效地存储和管理数据，满足各种用户的应用需求，包括信息管理需求和数据操作要求。
>
> * 信息管理要求：在数据库中应该存储和管理哪些数据对象。
> * 数据操作要求：对数据对象需要进行哪些操作，如查询、增、删、改、统计等操作

**数据库设计的目标**

数据库设计的目标是为用户和各种应用系统提供一个信息基础设施和高效率的运行环境。

> 高效率的运行环境是指：
>
> * 数据库数据的存取效率高
> * 数据库存储空间的利用率高
> * 数据库系统运行管理的效率高

**数据库设计的特点**

1. 基本规律：三分技术，七分管理，十二分基础数据
	* 管理：数据库建设项目管理，企业的业务管理
	* 基础数据：数据的收集、整理、组织和不断更新。
2. 结构（数据）设计和行为（处理）设计相结合
	* 将数据库结构设计和数据处理设计密切结合
	* 结构和行为分离的设计

**数据库设计的基本步骤**

1. 需求分析：是否充分与准确，决定了构建数据库的速度与质量
2. 概念结构设计：通过对用户需求进行综合、归纳与抽象，形成一个独立于具体数据库管理系统的概念模型
3. 逻辑结构设计：将概念结构转换为某个数据库管理系统所支持的数据模型，并对其进行优化
4. 物理结构设计：为逻辑数据结构选取一个最适合应用环境的物理结构，包括存储结构和存取方法
5. 数据库实施：
	* 根据逻辑设计和物理设计的结果构建数据库
	* 编写与调试应用程序
	* 组织数据入库并进行试运行
6. 数据库运行和维护：
	* 经过试运行后即可投入正式运行
	* 在运行过程中必须不断对其进行评估、调整与修改。

> 其中：需求分析和概念设计独立于任何数据库管理系统，逻辑设计和物理设计与选用的数据库管理系统密切相关

![](https://s2.loli.net/2022/04/28/CLbEQNcka6q1Sdy.png)



## 18 需求分析

需求分析就是分析用户的要求。是设计数据库的起点，其结果是否准确地反映了用户的实际要求，将直接影响到后面各个阶段的设计，并影响到设计结果是否合理和实用。

**需求分析的任务**

1. 详细调查现实世界要处理的对象（组织、部门、企业等）
2. 充分了解原系统（手工系统或计算机系统）工作概况
3. 明确用户的各种需求
4. 在此基础上确定新系统的功能
5. 新系统必须充分考虑今后可能的扩充和改变

> 调查的重点是“数据”和“处理”，获得用户对数据库的要求
>
> * 信息要求：
> 	* 用户需要从数据库中获得的信息的内容与性质
> 	* 由信息要求可以导出数据要求，即在数据库中需要存储哪些数据
> * 处理要求
> 	* 用户要完成的处理功能
> 	* 对处理性能的要求
> * 安全性与完整性要求

* 确定用户最终需求的难点
	* 用户缺少计算机知识，不能准确地表达自己的需求，他们所提出的需求往往不断地变化。
	* 设计人员缺少用户的专业知识，不易理解用户的真正需求，甚至误解用户的需求
* 解决方法
	* 设计人员必须不断深入地与用户进行交流，才能逐步确定用户的实际需求

### 18.1 需求分析方法

* 调查清楚用户的实际需求并进行初步分析
* 与用户达成共识
* 分析与表达这些需求

### 18.2 数据字典

* 数据字典是关于数据库中数据的描述，即元数据，不是数据本身。
* 数据字典在需求分析阶段建立，在数据库设计过程中不断修改、充实、完善。
* 数据字典是进行详细的数据收集和数据分析所获得的主要结果
* 注意：和关系数据库管理系统中数据字典的区别和联系

**数据字典的内容**

1. 数据项
2. 数据结构
3. 数据流
4. 数据存储
5. 处理过程

> * 数据项是数据的最小组成单位
> * 若干个数据项可以组成一个数据结构
> * 数据字典通过对数据项和数据结构的定义来描述数据流、数据存储的逻辑内容

#### 18.2.1 数据项

> 数据项是不可再分的数据单位

对数据项的描述：数据项描述 = {数据项名，数据项含义说明，别名，数据类型，长度，取值范围，取值含义，与其他数据项的逻辑关系，数据项之间的联系}

* “取值范围”、“与其它数据项的逻辑关系”定义了数据的完整性约束条件，是设计数据检验功能的依据
* 可以用关系规范化理论为指导，用数据依赖的概念分析和表示数据项之间的联系。

#### 18.2.2 数据结构

* 数据结构反映了数据之间的组合关系
* 一个数据结构可以由若干个数据项组成，也可以由若干个数据结构组成，或由若干个数据项和数据结构混合组成。

对数据结构的描述：数据结构描述 = {数据结构名，含义说明，组成：{数据项或数据结构}}

#### 18.2.3 数据流

> 数据流是数据结构在系统内传输的路径

对数据流的描述：数据流描述 = {数据流名，说明，数据流来源，数据流去向，组成：{数据结构}，平均流量，高峰期流量}

* 数据流来源：说明该数据流来自哪个过程
* 数据流去向：说明该数据流将到哪个过程去
* 平均流量：在单位时间（每天、每周、每月等）里的传输次数
* 高峰期流量：在高峰时期的数据流量

#### 18.2.4 数据存储

> 数据存储是数据结构停留或保存的地方，也是数据流的来源和去向之一。

对数据存储的描述：数据存储描述 = {数据存储名，说明，编号，输入的数据流，组成：{数据结构}，数据量，存取频度，存取方式}

* 存取频度：每小时、每天或每周存取次数，每次存取的数据量等信息
* 存取方式：批处理/联机处理；检索/更新；顺序检索/随机检索
* 输入的数据流：数据来源
* 输出的数据流：数据去向

#### 18.2.5 处理过程

> 处理过程的具体处理逻辑一般用判断表或判定树来描述，数据字典中只需要描述处理过程中的说明性信息

处理过程说明性信息的描述：处理过程描述 = {处理过程名，说明，输入：{数据流}，输出：{数据流}，处理：{简要说明}}

* 简要说明：说明该处理过程的功能及处理要求
	* 功能：该处理过程用来做什么
	* 处理要求：处理频度要求，如单位时间里处理多少事务，多少数据量、响应时间要求等
	* 处理要求是后面物理设计的输入及性能评价的标准

### 18.3 需求阶段的强调点

* 设计人员应该充分考虑到可能的扩充和改变，使设计易于更改，系统易于扩充。
* 必须强调用户的参与。



## 19 概念模型和ER模型

### 19.1 概念模型

将需求分析得到的用户需求抽象为信息结构（即概念模型）的过程就是概念结构设计。

**概念模型的特点**：

* 能真实、充分地反映现实世界，是现实世界的一个真实模型。
* 易于理解，从而可以用它和不熟悉计算机的用户交换意见。
* 易于更改，当应用环境和应用要求改变时，容易对概念模型修改和扩充
* 易于向关系、网状、层次等各种数据模型转换。

描述概念模型的工具：E-R 模型

**两个实体型之间的联系：**

* 一对一联系：如果对于实体集 $A$ 中的每一个实体，实体集 $B$ 中至多有一个（**也可以没有**）实体与之联系，反之亦然，则称实体集 $A$ 与实体集 $B$ 具有一对一联系，记为 $1 : 1$
* 一对多联系：如果对于实体集 $A$ 中的每一个实体，实体集 $B$ 中有 $n$ 个实体 $(n \ge 0)$ 与之联系，反之，对于实体集 $B$ 中的每一个实体，实体集 $A$ 中至多只有一个实体与之联系，则称实体集 $A$ 与实体集 $B$ 有一对多联系，记为 $1:n$
* 多对多联系：如果对于实体集 $A$ 中的每一个实体，实体集 $B$ 中有 $n$ 个实体 $(n \ge 0)$ 与之联系，反之，对于实体集 $B$ 中的每一个实体，实体集 $A$ 中也有 $m$ 个实体 $(m \ge 0)$ 与之联系，则称实体集 $A$ 与实体集 $B$ 具有多对多联系，记为 $m:n$

> 需要注意的是，联系中的某一方数量可以为0

除了两个实体型之间的联系，还有两个以上的实体型之间的联系，也分为一对一、一对多和多对多。比如说：课程、教师、参考书之间就存在着联系，一门课程有若干个教室讲授，一个老师只讲授一门课程，则课程与老师是 $1:n$ 的联系，一本参考书只供一门课程使用，一门课程可以用多本参考书，则两者之间是 $1:n$ 的联系。

![](https://s2.loli.net/2022/05/02/agKyFSqWpkUPYLH.png)

单个实体型之间也会存在联系，比如说职工实体型内部具有领导与被领导的关系，即某一职工（上司）“领导”若干名职工，而一名职工仅被另一个职工直接领导，所以是一对多的关系。

![](https://s2.loli.net/2022/05/02/Z8AlrFPmWUeaJSc.png)

### 19.2 E-R 模型

**联系的度**：参与联系的实体型的数目

* 2个实体型之间的联系度为2，也称为二元联系；
* 3个实体型之间的联系度为3，也称为三元联系；
* $N$ 个实体型之间的联系度 $N$，也称为 $N$ 元联系

#### 19.2.1 E-R 图的表示方法

1. 实体型：矩形表示，矩形框内写明实体名。
2. 属性：用椭圆形来表示，并用无向边将其与相应的实体型连接起来。

> 例如，学生实体具有学号、姓名、性别、出生年份、系、入学时间等属性，用E-R图可以如下方式表示

![](https://img-bed-1309306776.cos.ap-shanghai.myqcloud.com/img/20220503101003.png)

3. 联系：用来菱形表示，菱形框内写明联系明，并用无向边分别与有关实体型连接起来，同时在无向边旁标上联系的类型（$1:1$, $1:n$ 或 $m:n$）
4. 联系可以具有属性

#### 19.2.2 ISA联系

* 有的实体型是某个实体型的子类型，这种**父类-子类**联系称为“ISA”联系，用三角形表示。
* ISA联系的性质：子类继承了父类的所有属性，子类也可以有自己的属性。

![](https://img-bed-1309306776.cos.ap-shanghai.myqcloud.com/img/20220503101635.png)

**ISA联系-分类属性**

* 分类属性是父实体型的一个属性
* 分类属性的值把父实体型中的实体分派到子实体型中。

> 上图中的学生类别就是一个分类属性

**ISA联系-不相交约束与可重叠约束**

* 不相交约束：描述父类中的一个实体不能同时属于多个子类中的实体集，**即一个父类中的实体最多属于一个子类实体集。**（在三角形中打一个叉号来表示）
* 可重叠约束：父类中的一个实体能同时属于多个子类中的实体集。子类符号中没有叉号表示是可重叠的。

**ISA联系-完备性约束**

* 描述父类中的一个实体是否必须是某一个子类中的实体
	* 如果是，则叫做完全特化（Total specialization）
	* 否则的话叫做部分特化（Partial specialization）
* 完全特化用父类到子类的双线连接来表示
* 部分特化用父类到子类的单线连接来表示

![](https://img-bed-1309306776.cos.ap-shanghai.myqcloud.com/img/20220503102603.png)

**基数约束**

* 说明实体型中的任何一个实体可以在联系中出现的最少次数和最多次数
* 对实体之间一对一、一对多、多对多联系的细化
* 约束使用一个数对 $\min .. \max$ 来表示， $0 \le \min \le \max$。例如 $0 ..1$，$1..3$，$1..*$，其中 $*$ 代表无穷大。
* $\min = 1$ 的约束叫做强制参与约束，即被施加基数约束的实体型中的每个实体都要参与联系。
* $\min = 0$ 的约束叫做非强制参与约束，被施加基数约束的实体型中的实体可以出现在联系中，也可以不出现在联系中。

**Part-of 联系**

* 描述某个实体型是另一个实体型的一部分
* Part-of 联系可以分为两种情况
	* 非独占的 Part-of 联系，简称非独占联系：即整体实体如果被破坏，另一部分实体仍然可以独立存在，那么就是非独占的 Part-of 联系。
	* 独占的 Part-of 联系，简称独占联系：整体实体如果被破坏，部分实体不能存在。
* Part-of 联系如何表示
	* 用非强制参与联系表示非独占的 Part-of 联系
	* 用弱实体类型和识别联系来表示独占联系

**弱实体型和独占联系**

* 如果一个实体型的存在依赖于其他实体型的存在，则这个实体型叫做弱实体型，否则叫做强实体型。
* 用弱实体型和识别联系来表示独占联系，双矩阵表示弱实体型，双菱形表示识别联系。

![](https://img-bed-1309306776.cos.ap-shanghai.myqcloud.com/img/20220503103430.png)

## 20 概念结构设计

概念结构设计的方法：

1. 自顶向下：首先定义全局概念结构的框架，然后逐步细化。
2. 自底向上：首先定义各局部应用的概念结构，然后将它们集成起来，得到全局概念结构。
3. 逐步扩张：首先定义最重要的核心概念结构，然后向外扩充，以滚雪球的方式逐步生成其他概念结构，直至总体概念结构。
4. 混合策略：将自顶向下和自底向上相结合，用自顶向下策略设计一个全局概念结构的框架，以它为骨架集成由自底向上策略中设计的各局部概念结构。

**常用策略**：自顶向下进行需求分析，自底向上设计概念结构

**自底向上设计概念结构的步骤**：

1. 抽象数据并设计局部视图
2. 集成局部视图，得到全局概念结构

![image-20220503141351470](https://img-bed-1309306776.cos.ap-shanghai.myqcloud.com/img/image-20220503141351470.png)

### 20.1 实体与属性的划分

**原则**

* 为了简化 E-R 图的处置，现实世界的事物能作为属性对待的，**尽量**作为属性对待。
* 两条准则：
	1. 作为属性，不能再具有需要描述的性质。属性必须是不可分的数据项，不能包含其他属性。
	2. 属性不能与其他实体具有联系，即E-R图中所表示的联系是实体之间的联系。

### 20.2 有关 E-R 图

**E-R 图的集成**

* 合并。解决各分 E-R 图之间的冲突，将分 E-R 图合并起来生成初步 E-R 图
* 修改和重构。消除不必要的冗余，生成基本 E-R 图。

#### 20.2.1 合并E-R图

各个局部应用所面向的问题不同，各个子系统的 E-R图之间必定会存在许多不一致的地方，这称为冲突。子系统 E-R图之间的冲突主要有以下的三类：

* 属性冲突
* 命名冲突
* 结构冲突

#### 20.2.2 属性冲突

* 属性域冲突，即属性值的类型、取值范围或取值集合不同

	> 例如零件号，有的部门把它定义为整数，有的部门把它定义为字符串
	>
	> 年龄，某些部门以出生日期形式表示职工的年龄，而另一些部门用整数表示职工的年龄

* 属性取值单位冲突

	> 例如，零件的重要有的以公斤为单位，有的以斤为单位，有的以克为单位

#### 20.2.3 命名冲突

* 同名异义，即不同意义的对象在不同的局部应用中具有相同的名字。

* 异名同义（一义多名），即同一意义的对象在不同的局部应用中具有不同的名字。

	> 如对科研项目，财务科称为项目，科研处称为客体，生产管理处称为工程。

* 命名冲突

	* 可能发生在实体、联系一级上
	* 也可能发生在属性一级上
	* 通过讨论、协商等行政手段加以解决。

#### 20.2.4 结构冲突

* 同一对象在不同应用中具有不同的抽象

	> 例如，职工在某一局部应用中被当做实体，而在另一局部应用中则被当做属性。
	>
	> 解决方法：把属性变换为实体或把实体变换为属性，使同一对象具有相同的抽象。但仍然要遵循实体与属性的划分原则。

* 同一实体在不同子系统的E-R图中所包含的属性个数和属性排列次序不完全相同

	> 解决方法：使该实体的属性取各子系统的 E-R图中属性的并集，再适当调整属性的次序。

* 实体间的联系在不同的 E-R图中为不同的类型

	> 实体 $E_1$ 与 $E_2$ 在一个 E-R图中是多对多联系，在另一个 E-R图中是一对多联系
	>
	> 解决方法：根据应用的语义对实体联系的类型进行综合或调整。

#### 20.2.5 E-R图的修改和重构

消除不必要的冗余，设计基本 E-R图

* 所谓冗余的数据是指可由**基本数据导出的数据**，冗余的联系是指可由其他联系导出的联系。
* 消除冗余主要采用**分析方法**，即以数据字典和数据流图为依据，根据数据字典中关于数据项之间逻辑关系的说明来消除冗余。



## 21 逻辑结构设计

**逻辑结构设计的任务**

* 把概念结构设计阶段设计好的基本E-R图转换为与选用数据库管理系统产品所支持的数据模型相符合的逻辑结构。
* 转换内容：
	* E-R图由实体型、实体的属性和实体型之间的联系三个要素组成。
	* 关系模型的逻辑结构是一组关系模式的集合。
	* 将E-R图转换为关系模型：将实体型、实体的属性和实体型之间的联系转换为关系模式。

**实体型转换为关系模式**

* 关系的属性：实体的属性
* 关系的码：实体的码

### 21.1 转换原则

**1：1联系**

一个 $1:1$ 联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。

* 转换为一个独立的关系模式：
	* 关系的属性：与该联系相连的各实体的码以及联系本身的属性。
	* 关系的候选码：每个实体的码均是该关系的候选码。
* 与某一端实体对应的关系模式合并
	* 合并后关系的属性：加入对应关系的码和联系本身的属性。
	* 合并后关系的码：不变。

**1：n联系**

一个 $1:n$ 联系可以转换为一个独立的关系模式，也可以与 $n$ 端对应的关系模式合并

* 转换为一个独立的关系模式：
	* 关系的属性：与该联系相连的各实体的码以及联系本身的属性
	* 关系的码： $n$ 端实体的码
* 与 $n$ 端对应的关系模式合并
	* 合并后关系的属性：在 $n$ 端关系中加入 $1$ 端关系的码和联系本身的属性
	* 合并后关系的码：不变
	* 可以减少系统中的关系个数

**m：n联系**

* 一个 $m: n$ 联系转换为一个关系模式：
	* 关系的属性：与该联系相连的各实体的码以及联系本身的属性
	* 关系的码：各实体码的组合



## 22 物理结构设计

* 数据库在物理设备上的存储结构与存取方法称为数据库的物理结构，它依赖于选定的数据库管理系统。
* 为一个给定的逻辑数据模型选取一个最适合应用要求的物理结构的过程，就是数据库的物理设计。

**数据库物理设计的步骤：**

* 确定数据库的物理结构，在关系数据库中主要指存取方法和存储结构;
* 对物理结构进行评价，评价的重点是时间和空间效率
* 若评价结果满足原设计要求，则可进入到物理实施阶段。否则，就需要重新设计或修改物理结构，有时甚至要返回逻辑设计阶段修改数据模型。

**数据库物理设计的内容和方法：**

* 设计物理数据库结构的准备工作：
	* 充分了解应用环境，详细分析要运行的事物，以获得选择物理数据库设计所需参数。
	* 充分了解所用关系型数据库管理系统的内部特征，特别是系统提供的存取方法和存储结构。
* 关系数据库物理设计的内容：
	* 为关系模式选取存取方法
	* 设计关系、索引等数据库文件的物理存储结构。
* 物理数据库设计所需参数：
	* 数据库查询事务：查询的关系，查询的条件所涉及的属性，连接条件所涉及的属性，查询的投影属性。
	* 数据更新事务：被更新的关系，每个关系上的更新操作条件所涉及的属性。
	* 修改操作要改变的属性值。
* 每个事务在各关系上运行的频率和性能要求

### 22.1 关系模式存取方法选择

数据库系统是多用户共享的系统，对同一个关系要建立多条存取路径才能满足多用户的多种应用要求。物理结构设计的任务之一是根据关系数据库管理系统支持的存取方法确定选择哪些存取方法。

数据库管理系统常用存取方法：

1. $B+$ 数索引存取方法
2. $Hash$ 索引存取方法
3. 聚簇存取方法

#### 22.1.1 B+树索引存取方法的选择

选择索引存取方法的主要内容：**根据应用要求确定**

* 对哪些属性列建立索引
* 对哪些属性列建立组合索引
* 对哪些索引要设计为唯一索引

**选择索引存取方法的一般规则**

* 如果一个（或一组）属性经常在查询条件中出现，则考虑在这个（或这组）属性上建立索引（或组合索引）
* 如果一个属性经常作为最大值和最小值等聚集函数的参数，则考虑在这个属性上建立索引
* 如果一个（或一组）属性经常在连接操作的连接条件中出现，则考虑在这个（或这组）属性上建立索引

> 需要注意的是，并不是索引越多数据库存取的效率就会越高，关系上定义的索引数过多会带来较多的额外开销（维护、查找索引的开销)。

#### 22.1.2 Hash索引存取方法的选择

如果一个关系的属性主要出现在**等值连接条件**中或主要出现在**等值比较选择条件**中，而且满足下列两个条件之一

* 该关系的大小可预知，而且不变；
* 该关系的大小动态改变，但所选用的数据库管理系统提供了动态Hash存取方法。

#### 22.1.3 聚簇索引存取方法的选择

既适用于单个关系独立聚簇，也适用于经常进行连接操作的多个关系。

* 把多个连接的元组按连接属性值聚集存放
* 从而实现多个关系的“预连接”，提高连接操作的效率。

选择聚簇存储方法，即确定需要建立多少个聚簇，每个聚簇中包含哪些关系。一个数据库可以建立多个聚簇，一个关系**只能**加入一个聚簇
**设计候选聚簇**

* 常在一起进行连接操作的关系可以建立组合聚簇
* 如果一个关系的一组属性经常出现在相等比较条件中，则该单个关系可建立聚簇；
* 如果一个关系的一个（或一组）属性上的值重复率很高，则此单个关系可建立聚簇。

检查候选聚簇中的关系，取消其中不必要的关系

* 从聚簇中删除经常进行全表扫描的关系
* 从聚簇中删除更新操作远多于连接操作的关系
* 从聚簇中删除重复出现的关系
* 当一个关系同时加入多个聚簇时，必须从这多个聚簇方案（包括不建立聚簇）中选择一个较优的，即在这个聚簇上运行各种事务的总代价最小。

**聚簇的局限性**

* 聚簇只能提高某些特定应用的性能
* 建立与维护聚簇的开销相当大
	* 对已有关系建立聚簇，将导致关系中元组的物理存储位置移动，并使此关系上原有的所有索引无效，必须重建。
	* 当一个元组的聚簇码改变时，该元组的存储位置也要做相应改变。

当通过聚簇码进行访问或连接是该关系的主要应用，与聚簇码无关的其他访问很少或者是次要的时，可以使用聚簇。尤其当SQL语句中包含有与聚簇码有关的ORDER BY, GROUP BY, UNION, DISTINCT等子句或短语时，使用聚簇特别有利，可以省去或减化对结果集的排序操作。

### 22.2 确定数据库的存储结构

确定数据库物理结构主要指确定数据的存放位置和存储结构，包括：确定关系、索引、聚簇、日志、备份等的存储安排和存储结构，确定系统配置等。

影响数据存放位置和存储结构的因素：

* 硬件环境
* 应用需求：存取时间、存储空间利用率、维护代价（这三个方面常常是相互矛盾的，必须进行权衡，选择一个折中的方案）

确定数据存放位置的基本原则：根据应用情况将易变部分与稳定部分分开存放，经常存取部分与存取频率较低部分分开存放。

确定系统配置：系统为这些变量赋予了合理的缺省值。进行物理设计时需要根据应用环境确认参数值，使系统性能最优，同时也要根据系统实际运行情况来做进一步的调整，以切实改进系统性能。（包括同时使用数据库的用户数，同时打开的数据库对象数，内存分配参数等）

评价物理结构：对数据库物理设计过程中产生的多种方案进行评价，从中选择一个较优的方案作为数据库的物理结构。

评价方法：定量估算各种方案

* 存储空间
* 存取时间
* 维护代价



## 23 数据库的实施和维护

> 略 非重点



## 24 面向驱动的数据库编程

不同的数据库管理系统通过不同的驱动来加载。具体可看 [JDBCLeraning](https://www.tutorialspoint.com/jdbc/index.htm)



## 25 过程化SQL

过程化SQL是SQL的扩展，在SQL的基础上增加了过程化语句功能，基本结构是 **块**，每个块完成一个逻辑操作，且块与块是可以嵌套的。

> 需要注意的是，这部分`SQL` 与 `MYSQL` 语法是有区别的！

**定义块与执行块**

```sql
DECLARE <变量> | <常量> | <游标> | <异常>
```

* 定义的变量、常量等只能在该基本块中使用
* 当基本块执行结束时，定义就不再存在。

```sql
BEGIN
	<SQL语句> | <过程化SQL的流程控制语句>
EXCCEPTION
	<异常处理部分>
END;
```

**变量和常量的定义**

变量定义：

```sql
DECLARE <变量名> <数据类型> [[NOT NULL] := <初值表达式>]
DECLARE <变量名> <数据类型> [[NOT NULL] <初值表达式>]
```

常量定义：

```sql
DECLARE <常量名> <数据类型> CONSTANT := <常量表达式>
```

**注意：**常量在声明时必须要给一个值，并且该值在存在期间或常量的作用域内是不能改变的。如果试图改变常量，那么过程化SQL将会返回一个异常。

赋值语句：

```sql
<变量名称> := <表达式>
```

**流程控制-条件控制语句**

```sql
IF <condition> THEN
	<SQL语句>
END IF;

IF <condition> THEN
	<SQL语句>
ELSE
	<SQL语句>
END IF;
```

> `MYSQL` 中有 `IF()` 和 `IFNULL()` 函数来在语句内部进行条件的控制。`IF()` 是可以嵌套的

**流程控制-循环控制语句**

```sql
LOOP
-- 提供EXIT/BREAK/LEAVE等循环结束语句 --
	<SQL语句>
END LOOP;

WHILE <condition> LOOP
	<SQL语句>
END LOOP;

FOR <count> IN [REVERSE] <bound1> ... <bound2> LOOP
	<SQL语句>
END LOOP;
```

* 如果过程化SQL在执行时出现异常，则应该让程序在产生异常的语句处停下来，根据异常的类型去执行异常处理语句
* SQL标准对数据库服务器提供什么样的异常处理做出了建议，要求过程化SQL管理器提供完善的异常处理机制

**存储过程**

存储过程化SQL语句书写的过程，经过编译和优化后存储在数据库服务器中，使用的时候只要调用就可以了，优点：

* 运行效率高
* 降低了客户机和服务器之间的通信量
* 方便实施企业规则

创建存储过程：

```sql
CREATE OR REPLACE PROCEDURE <过程名>([<参数1>, <参数2>]) AS <过程化SQL块>
```

* 过程名：数据库服务器合法的对象标识
* 参数列表：用名字来标识调用时给出的参数值，必须指定值的数据类型。参数也可以定义输入参数、输出参数或输入/输出参数，默认为输入参数
* 过程体：是一个<过程化SQL块>，包括声明部分和可执行语句部分



## 26 事务

事务（Transaction）是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。

事务和程序是两个概念：

* 在关系数据库中，一个事务可以是一条SQL语句，一组SQL语句或者整个程序
* 一个程序通常包含多个事务

**事务是恢复和并发控制的<span style='color: red'>基本单位</span>**

### 26.1 定义事务

1. 显式定义事务

	```sql
	BEGIN TRANSACTION
		<SQL语句1>
		<SQL语句2>
		...
	COMMIT;
	
	BEGIN TRANSACTION
		<SQL语句1>
		<SQL语句2>
		...
	ROLLBACK;
	```

	`COMMIT`：

	1. 事务正常结束
	2. 提交事务的所有操作（读+更新）
	3. 事务中所有对数据库的更新写回到磁盘上的物理数据库中

	`ROLLBACK`：

	1. 事务异常终止
	2. 事务运行的过程中发生了故障，不能继续执行
	3. 系统将事务中对数据库的所有已完成的操作全部撤销
	4. 事务滚回到开始时的状态

2. 隐式方式：当用户没有显式地定义事务时，数据库管理系统按缺省规定自动划分事务。

### 26.2 事务的特性（ACID）

#### 26.2.1 原子性 Atomicity

事务是数据库的**逻辑工作单位**：事务中包括的所有操作要么全部都一起做了，要么都不做。



#### 26.2.2 一致性 Consistency

* 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态
* 一致性状态：数据库中只包含成功事务提交的结果
* 不一致状态：
	* 数据库系统运行中发生故障，有些事务尚未完成就被迫中断；
	* 这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态

#### 26.2.3 隔离性 Isolation

* 一个事务的执行不能被其他事务干扰
* 一个事务内部的操作及使用的数据对其他并发事务是隔离的
* 并发执行的各个事务之间不能互相干扰

#### 26.2.4 持续性 Durability

* 一个事务一旦提交，它对数据库中数据的改变就应该是**永久性**的。
* 接下来的其他操作或故障不应该对其执行结果有任何影响。



**破坏事务ACID特性的因素**

* 多个事务并行运行时，不同事务的操作交叉执行：数据库管理系统必须保证多个事务的交叉运行不影响这些事务的隔离性
* 事务在运行过程中被强行停止：数据库管理系统必须保证被强行终止的事务对数据库和其他事务没有任何影响

> 后面主要介绍的是数据库遇到错误和发生异常时的策略，主要是通过日志文件来 redo 和 undo 某些事务。同时介绍了需要定时转储数据库中的数据和日志文件等。
>
> 日志文件的记录方式有所不同，但大体的方式就是记录事务的每一条操作，然后对事务的操作进行 redo，直到恢复到故障时刻的数据。
>
> 等级日志文件需要满足两条原则：
>
> 1. 登记的次序严格按照并发事务执行的时间次序
> 2. 必须要先写日志文件，然后写数据库：如果先写数据库再写日志文件，那么写数据库过程中若是发生故障，则日志文件里就会缺失一部分的事务执行记录。如果先写了数据库修改，而在日志文件中没有登记下这个修改，则以后就无法恢复这个修改了



## 27 并发控制

事务并发执行带来的问题：

1. 会产生多个事务同时存取同一数据的情况
2. 可能会存取和存储不正确的数据，破坏事务隔离性和数据库的一致性

**多事务执行方式：**

1. 事务串行执行：每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后方能运行。这种实现不能充分利用系统资源，发挥数据库共享资源的特点。

2. 交叉并发方式（Interleaved Concurrency）：在单处理机系统中，事务的并行执行是这些并行事务的并行操作轮流交叉执行。单处理机系统中的并行事务并没有真正地并行运行，但能够减少处理机的空间时间，提高系统的效率。在多处理机上，每个不同的核可以同时处理不同的事务。

	> 对时间进行切片，比如先执行事务一的前三分一，再去执行事务二的前三分一，来回分配时间以达到宏观上并行的效果（单处理机上微观来看仍然是串行的）

3. 同时并发方式（Simultaneous Concurrency）：多处理机系统中，每个处理机可以运行一个事务，多个处理机可以同时运行多个事务，实现多个事务真正的并行运行。这是最理想的并发方式，但受制于硬件环境，同时也需要更复杂的并发方式机制

**事务是并发控制的<span style='color: red'>基本单位</span>>**

并发控制机制的任务：

* 对并发操作进行正确调度
* 保证事务的隔离性
* 保证数据库的一致性

并发操作可能带来的数据不一致性：

* 丢失修改（Lost Update）：丢失修改指的是两个事务读入了同一个数据，又分别先后写回数据库，由于读取时两者是同时读取，修改时并不知道另一个事务修改了该数据，于是写回的时候有一个事务的更新就被另一个事务给覆盖了。
* 不可重复读（Non-repeatable Read）：不可重复读指的是事务一读取数据后，事务二更新了数据导致事务一无法再读取到之前的结果，有时也称为幻影现象（Phantom Row）：
	* 事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读该数据时，得到与前一次不同的值
	* 事务T1按一定条件从数据库中读取了某些数据记录后，事务T2删除了其中部分记录，当T1再次按相同条件读取数据时，发现某些记录神秘地消失了。
	* 事务T1按一定条件从数据库中读取某些数据记录后，事务T2插入了一些记录，当T1再次按相同条件读取数据时，发现多了一些记录。
* 读脏数据（Dirty Read）：
	* 事务T1修改某一数据，并将其写回磁盘
	* 事务T2读取同一数据后，T1由于某种原因被撤销（ROLLBACK）
	* 这时T1已修改过的数据恢复原值，T2读到的数据就与数据库中的数据不一致
	* T2读到的数据就为“脏”数据，即不正确的数据

**数据不一致性**：由于并发操作破坏了事务的隔离性

并发控制就是要用正确的方式调度并发操作，使一个用户事务的执行不受其他事务的干扰，从而避免造成数据的不一致性

对数据库的应用有时允许某些不一致性，例如有些统计工作涉及数据量很大，读到一些“脏”数据对统计精度没什么影响，可以降低对一致性的要求以减少系统开销

**并发控制的主要技术**

* 封锁（Locking）
* 时间戳（Timestamp）
* 乐观控制法
* 多版本并发控制（MVCC）



## 28 封锁

* 封锁就是事务T在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁
* 加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象。
* 封锁是实现并发控制的一个非常重要的技术
* 一个事务对某个数据对象加锁后究竟拥有什么样的控制由封锁的类型决定。
* 基本封锁类型
	* 排它锁（Exclusive Locks，简记为X锁）
	* 共享锁（Share Locks，简记为S锁）

### 28.1 锁的类型

1. 排它锁：又称为写锁
	* 若事务T对数据对象A加上X锁，则**只允许**T读取和修改A，<span style='color: red'>其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。</span>
	* 保证其他事务在T释放A上的锁之前不能再读取和修改A。
2. 共享锁：又称为读锁
	* 若事务T对数据对象A加上S锁，则事务T**可以读但不能修改**A，<span style='color: red'>其它事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。</span>
	* 保证其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

**锁的相容矩阵**

| T2/T1 |  X   |  S   |  -   |
| :---: | :--: | :--: | :--: |
|   X   |  N   |  N   |  Y   |
|   S   |  N   |  Y   |  Y   |
|   -   |  Y   |  Y   |  Y   |

在锁的相容矩阵中：

* 最左边一列表示事务T1已经获得的数据对象上的锁的类型，其中横线表示没有加锁。
* 最上面一行表示另一事务T2对同一数据对象发出的封锁请求。
* T2的封锁请求能否被满足用矩阵中的Y和N表示:
	* Y表示事务T2的封锁要求与T1已持有的锁相容，封锁请求可以满足
	* N表示T2的封锁请求与T1已持有的锁冲突，T2的请求被拒绝

在运用X锁和S锁对数据对象加锁的时候，需要约定一些规则，这些规则称为封锁协议（Locking Protocol），主要包括：事务何时申请X锁或S锁，事务的持锁时间应该多长，事务应该何时释放锁。

对封锁方式规定不同的规则，就形成了各种不同的封锁协议，它们分别在不同的程度上为并发操作的正确调度提供一定的保证。



### 28.2 一级封锁协议

内容：事务T在修改数据R之前必须先对其加X锁，直到事务结束才能释放。

> 事务结束的标志：
>
> * 正常结束（COMMIT）
> * 非正常结束（ROLLBACK）

一级封锁协议可以防止丢失修改，并保证事务T是可恢复的。在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它不能保证可重复读和不读脏数据。

#### 28.2.1 例子

![image-20220509160044691](https://img-bed-1309306776.cos.ap-shanghai.myqcloud.com/img/image-20220509160044691.png)



### 28.3 二级封锁协议

内容：一级封锁协议加上事务T在读取数据R之前必须先对其加上S锁，**<span style='color:red'>读完后</span>**即可释放S锁。

二级封锁协议可以防止丢失修改和读“脏”数据。在二级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。

#### 28.3.1 例子

![image-20220509160335777](https://img-bed-1309306776.cos.ap-shanghai.myqcloud.com/img/image-20220509160335777.png)



### 28.4 三级封锁协议

内容：一级封锁协议机上事务T在读取数据R之前必须先对其加S锁，**<span style='color: red'>直到事务结束</span>**才释放。

三级封锁协议可防止丢失修改、读脏数据和不可重复读。

#### 28.4.1 例子

![image-20220509160641141](https://img-bed-1309306776.cos.ap-shanghai.myqcloud.com/img/image-20220509160641141.png)



* 三级协议的主要区别：什么操作需要申请封锁以及何时释放锁。
* 不同的封锁协议使事务达到的一致性级别不同：封锁协议级别越高，一致性程度越高

<table>
    <tr>
        <td>&nbsp;</td>
        <td colspan="2">X锁</td>
        <td colspan="2">S锁</td>
        <td colspan="3">一致性保证</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td>操作结束释放</td>
        <td>事务结束释放</td>
        <td>操作结束释放</td>
        <td>事务结束释放</td>
        <td>不丢失修改</td>
        <td>不读“脏”数据</td>
        <td>可重复读</td>
    </tr>
    <tr>
        <td>一级封锁协议</td>
        <td>&nbsp;</td>
        <td>是</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td>是</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
    </tr>
    <tr>
        <td>二级封锁协议</td>
        <td>&nbsp;</td>
        <td>是</td>
        <td>是</td>
        <td>&nbsp;</td>
        <td>是</td>
        <td>是</td>
        <td>&nbsp;</td>
    </tr>
    <tr>
        <td>三级封锁协议</td>
        <td>&nbsp;</td>
        <td>是</td>
        <td>&nbsp;</td>
        <td>是</td>
        <td>是</td>
        <td>是</td>
        <td>是</td>
    </tr>
</table>



### 28.5 活锁

由于并发之间的调度其实不是可预测的，所以有可能某个事务在并发中会处于永远等待的状态，这个情况我们称为“活锁”。解决活锁一般是采用**先来先服务（First Come First Service, FCFS）**的处理。下面的情形介绍了一种典型的活锁情况：

* 事务 $T_1$ 封锁了数据 $R$
* 事务 $T_2$ 又请求封锁 $R$，于是 $T_2$ 等待。
* $T_3$ 也请求封锁 $R$，当 $T_1$ 释放了 $R$ 上的封锁之后系统首先批准了$T_3$ 的请求，$T_2$ 仍然等待。
* $T_4$ 又请求封锁 $R$，当 $T_3$ 释放了 $R$ 上的封锁之后系统又批准了 $T_4$ 的请求……
* $T_2$ 有可能永远等待，这就是活锁的情形

**先来先服务**

当多个事务请求封锁同一个数据对象的时候，DBMS按请求封锁的先手次序对这些事务排队，该数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁



### 28.6 死锁

典型的情况：

* 事务 $T_1$ 封锁了数据 $R_1$
* $T_2$ 封锁了数据 $R_2$
* $T_1$ 又请求封锁 $R_2$ ，因 $T_2$ 已封锁了 $R_2$ ，于是 $T_1$ 等待 $T_2$ 释放$R_2$ 上的锁
* 接着 $T_2$ 又申请封锁 $R_1$ ，因 $T_1$ 已封锁了 $R_1$ ，$T_2$ 也只能等待 $T_1$ 释放 $R_1$ 上的锁
* 这样 $T_1$ 在等待 $T_2$ ，而 $T_2$ 又在等待 $T_1$ ，T1和T2两个事务永远不能结束，形成死锁

#### 28.6.1 死锁的预防

产生死锁的原因是两个或多个事务都已封锁了一些数据对象，然后又都请求对已为其他事务封锁的数据对象加锁，从而出现死等待。

预防死锁的主要策略就是破坏产生死锁的条件，一般有如下的两种方法：

1. 一次封锁法：要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行。

	> 存在的问题：降低了系统的并发度。同时要实现精确的确定需要封锁的对象是比较困难的。

2. 顺序封锁法：预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。

	> 存在的问题：维护成本比较高，随着数据的不断更新需要不断维护这个封锁顺序。同时也很难实现，因为事务执行期间的封锁请求可能会动态变化，很难确定某个事务要先封锁哪一个对象。

上述两种方法一般是OS上用的预防死锁的方法，在DBMS中一般采用诊断出死锁并解除死锁的办法。



#### 28.6.2 死锁的诊断

1. 超时法：如果一个事务的等待时间超过规定的时间，就认为发生了死锁。

	> 优点：实现简单：
	>
	> 缺点：有可能会误判死锁，且如果时间设置太长，则死锁发生后可能不能及时发现。

2. 等待图法：并发控制子系统周期性地（比如每隔数秒）生成事务等待图来检测事务是否有回路，有的话则表示系统中出现了死锁。

#### 28.6.3 死锁的解除

* 选择一个处理死锁代价最小的事务，将其撤消
* 释放此事务持有的所有的锁，使其它事务能继续运行下去



## 29 事务调度

数据库管理系统对并发事务不同的调度可能会产生不同的结果。串行调度是正确的，执行结果等价于串行调度的调度也是正确的，称为可串行化（Serializable）调度。

**可串行化调度**：多个事务的并发执行时正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同。

**可串行性（Serializability）**：可串行性是并发事务正确调度的准则。一个给定的并发调度，当且仅当它是可串行化的，才认为是正确的调度。



### 29.1 冲突可串行化

**冲突可串行化**是一个比可串行化**更严格**的条件，商用系统中的调度器采用。

**冲突操作：**冲突操作是指不同的事务对同一数据的读写操作和写写操作。除此之外的其他操作是不冲突的操作。

**不能交换的动作**：

* 同一事物的两个操作
* 不同事务的冲突操作。

一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度Sc’，如果Sc’是串行的，称调度Sc是**冲突可串行化的调度**

* 若一个调度是冲突可串行化，则一定是可串行化的调度
* 可用这种方法判断一个调度是否是冲突可串行化的

冲突可串行化调度是可串行化调度的**充分条件**，不是必要条件。还有不满足冲突可串行化条件的可串行化调度。



### 29.2 两段锁协议

数据库管理系统普遍采用**<span style='color: red'>两段锁协议</span>**的方法实现并发调度的可串行性，从而保证调度的正确性

两段锁协议：两段锁协议是指所有事务必须分两个阶段，对数据项**加锁**和对数据项**解锁**

* 在对任何数据进行读、写操作之前，事务**首先要获得对该数据的封锁**
* 在释放一个封锁之后，事务**不再申请和获得任何其他封锁**



**“两段”锁的含义**：事务分为两个阶段

* 第一阶段是获得封锁，也称为**扩展阶段**：事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁
* 第二阶段是释放封锁，也称为**收缩阶段**：事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁



**遵守两段锁协议的调度一定是一个可串行化的调度。**

* 事务遵守两段锁协议是可串行化调度的**充分条件**，而不是必要条件。
* 若并发事务都遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的
* 若并发事务的一个调度是可串行化的，不一定所有事务都符合两段锁协议



#### 29.2.1 两段锁协议与防止死锁的一次封锁法区别

* 一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行，因此一次封锁法遵守两段锁协议
* 但是两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务**可能发生死锁**



## 30 封锁粒度

封锁对象的大小称为封锁粒度（Granularity）。封锁的对象包括逻辑单元和物理单元。



**选择封锁粒度原则**

* 封锁粒度与系统的并发度和并发控制的开销密切相关。
	* 封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小；
	* 封锁的粒度越小，并发度较高，但系统开销也就越大

> 例：若封锁粒度是数据页，事务T1需要修改元组L1，则T1必须对包含L1的整个数据页A加锁。如果T1对A加锁后事务T2要修改A中元组L2，则T2被迫等待，直到T1释放A。
>
> 如果封锁粒度是元组，则T1和T2可以同时对L1和L2加锁，不需要互相等待，提高了系统的并行度。
>
> 又如，事务T需要读取整个表，若封锁粒度是元组，T必须对表中的每一个元组加锁，开销极大



### 30.1 多粒度封锁

**多粒度封锁（Multiple Granularity Locking）**：在一个系统中同时支持多种封锁粒度提供不同的事务选择。

**如何选择封锁粒度**：同时考虑<span style='color: red'>封锁开销</span>和<span style='color: red'>并发度</span>两个因素, 适当选择封锁粒度：

* 需要处理多个关系的大量元组的用户事务：以数据库为封锁单位
* 需要处理大量元组的用户事务：以关系为封锁单元
* 只处理少量元组的用户事务：以元组为封锁单位



**多粒度树**：

* 以树形结构来表示多级封锁粒度
* 根结点是整个数据库，表示最大的粒度
* 叶结点表示最小的数据粒度

![image-20220510205931663](https://img-bed-1309306776.cos.ap-shanghai.myqcloud.com/img/image-20220510205931663.png)



**多粒度封锁协议**

* 允许多粒度树中的每个结点被独立地加锁
* 对一个结点加锁意味着这个结点的所有**后裔结点（即子节点）**也被加以同样类型的锁
* 在多粒度封锁中一个数据对象可能以两种方式封锁：
	* 显式封锁: 直接加到数据对象上的封锁
	* 隐式封锁:是该数据对象没有独立加锁，是由于其上级结点加锁而使该数据对象加上了锁
* 显式封锁和隐式封锁的效果是一样的



### 30.2 意向锁

引进意向锁（intention lock）目的：提高对某个数据对象加锁时系统的检查效率

内容：如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁。对任一结点加基本锁，必须先对它的上层结点加意向锁。例如，对任一元组加锁时，必须先对它所在的数据库和关系加意向锁

**常用意向锁**

* 共享意向排它锁（Share Intent Exclusive Lock，简称SIX锁）
	* 如果对一个数据对象加SIX锁，表示对它加S锁，再加IX锁，即SIX = S + IX。
	* 例：对某个表加SIX锁，则表示该事务要读整个表（所以要对该表加S锁），同时会更新个别元组（所以要对该表加IX锁）。
* 意向共享锁（Intent Share Lock，简称IS锁）
	* 如果对一个数据对象加IS锁，表示它的后裔结点拟（意向）加S锁
	* 例如：事务T1要对R1中某个元组加S锁，则要首先对关系R1和数据库加IS锁
* 意向排它锁（Intent Exclusive Lock，简称IX锁）
	* 如果对一个数据对象加IX锁，表示它的后裔结点拟（意向）加X锁
	* 例如：事务T1要对R1中某个元组加X锁，则要首先对关系R1和数据库加IX锁



**意向锁的相容矩阵**

| &nbsp; |  S   |  X   |  IS  | IX   | SIX  | -    |
| :----: | :--: | :--: | :--: | ---- | ---- | ---- |
|   S    |  Y   |  N   |  Y   | N    | N    | Y    |
|   X    |  N   |  N   |  N   | N    | N    | Y    |
|   IS   |  Y   |  N   |  Y   | Y    | Y    | Y    |
|   IX   |  N   |  N   |  Y   | Y    | N    | Y    |
|  SIX   |  N   |  N   |  Y   | N    | N    | Y    |
|   -    |  Y   |  Y   |  Y   | Y    | Y    | Y    |



**锁的强度**

锁的强度的偏序关系：

![](https://img-bed-1309306776.cos.ap-shanghai.myqcloud.com/img/20220511161242.png)

* 锁的强度是指它对其他锁的排斥程度
* 一个事务在申请封锁时以强锁代替弱锁是安全的，反之则不然

**具有意向锁的多粒度封锁方法**

* 申请封锁时应该按自上而下的次序进行
* 释放封锁时则应该按自下而上的次序进行
* 具有意向锁的多粒度封锁方法：
	* 提高了系统的并发度
	* 减少了加锁和解锁的开销
	* 在实际的DBMS产品中得到广泛的应用。



## 31 查询处理

![image-20220511161450799](https://img-bed-1309306776.cos.ap-shanghai.myqcloud.com/img/image-20220511161450799.png)



### 31.1 查询分析

查询分析的任务：对查询语句进行扫描、词法分析和语法分析

* 词法分析：从查询语句中识别出正确的语言符号
* 语法分析：进行语法检查

> 个人理解：类似于编译器做的编译工作，主要就是检查语法的正确性。（注意这步还不会检查关系名和属性名的有效性，而是要到查询检查中才会检查）



### 31.2 查询检查

查询检查的任务：

* 合法权检查
* 视图转换
* 安全性检查
* 完整性**初步**检查

根据数据字典中有关的模式定义检查语句中的数据库对象，如关系名、属性名是否存在和有效。如果是对视图的操作，则要用 **视图消解方法** 把堆视图的操作转换成对基本表的操作。

根据数据字典中的用户权限和完整性约束定义对用户的存取权限进行检查（检查执行该查询的用户是否有对应的权限）

检查通过后把SQL查询语句转换成内部表示，即等价的关系代数表达式。

关系数据库管理系统一般都用 **查询树**，也称为 **<span style='color: red'>语法分析树</span>** 来表示扩展的关系代数表达式。



### 31.3 查询优化

查询优化的任务：选择一个高效执行的查询处理策略

**查询优化的分类**：

1. 代数优化/逻辑优化：指关系代数表达式的优化（比如优化顺序或者替换为效率更高的查询方法）
2. 物理优化：指存取路径和底层操作算法的选择。

**查询优化的选择依据**：

* 基于规则（rule based）
* 基于代价（cost based）
* 基于语义（semantic based）



### 31.4 查询执行

查询执行的任务：依据优化器得到的执行策略生成查询执行计划

**代码生成器（Code Generator）** 生成执行查询计划的代码

两种执行的方法：

* 自顶向下
* 自底向上



### 31.5 选择操作的实现

**选择操作的典型实现方法**：

1. 全表扫描方法（Table Scan）：对查询的基本表顺序扫描，逐一检查每个元组是否满足选择条件，把满足条件的元组作为结果输出

	> 适合小表不适合大表

2. 索引扫描方法（Index Scan）：适用于选择条件中的属性上有索引（例如B+树索引或Hash索引），通过索引先找到满足条件的元组主码或元组指针，再通过元组指针直接在查询的基本表中找到元组。



假设我们有一个 `student` 表，我们需要执行以下的语句：

```mysql
SELECT *
FROM `student`
WHERE <条件表达式>
```

这里的条件表达式有以下四种：

1. 无条件（即查询所有元组）
2. `student_no = '201215121'`
3. `student_age > 20`
4. `student_dept = 'CS' AND student_age > 20`

**全表扫描算法**：

假设可以使用的内存为 $M$ 块，全表扫描算法的思想如下所示：

1. 按照物理次序读取 `student` 的 $M$ 块到内存。
2. 检查内存你的每个元组 $t$，如果满足选择条件，则输出 $t$
3. 如果 `student` 还有其他块未被处理，则重复1和2

**索引扫描算法**

假设现在的条件表达式是第二种，且 `student_no` 上有索引。则索引扫描算法就会：

1. 通过索引（或散列）得到 `student_no` 为 `'201215121'` 元组的指针
2. 通过元组指针在 `student` 表中检索到该学生。

假设现在的条件表达式是第三种，且 `student_age` 上B+树索引。则索引扫描算法就会：

1. 使用B+树索引找到 `student_age = 20` 的索引项，以此为入口点在B+树的顺序集上得到 `student_age > 20` 的所有元组指针
2. 通过这些元组指针到 `student` 表中检索到所有年龄大于20的学生

假设现在的条件表达式是第四种，且 `student_dept` 和 `student_age` 上都有索引（可能是单列索引也可能是组合索引）。则索引扫描算法可能会有以下两种实现：

1. 分别利用 Index Scan 找到 `student_dept = 'CS'` 的一组元祖指针和 `student_age > 20` 的另一组元祖指针，然后求这两组指针的交集，再到 `student` 表中检索。
2. 找到 `student_dept = 'CS'` 的一组元组指针，通过这些元组指针到 `student` 表中检索，并对得到的元组检查另一些选择条件（如 `student_age > 20` 是否满足） 



### 31.6 连接操作的实现

连接操作是查询处理中最耗时的操作之一，本节只讨论等值连接（或自然连接）最常用的实现算法：

1. 嵌套循环算法（Nested Loop Join）
2. 排序-合并算法（Sort-Merge Join 或 Merge Join）
3. 索引连接（Index Join）算法
4. Hash Join 算法



以如下的查询语句为例子：

```mysql
SELECT *
FROM student, student_class
WHERE `student`.`student_no` = `student_class`.`student_no`;
```

**嵌套循环算法（Nested Loop Join）**：

* 对外层循环（`student` 表）的每一个元组，检索内层循环（`student_class` 表）中的每一个元组。
* 检查这两个元组在连接属性 `student_no` 上是否相等。
* 如果满足连接条件，则串接后作为结果输出，直到外层循环表中的元组处理完为止。

> 即一个二重循环，Java等价代码可以这样表示：
>
> ```java
> List<Student> studentList;
> List<StudentClass> studentClassList;
> List<Answer> ansList; // 这是student和student_class 连接的答案元组
> 
> for (Student student : studentList) {
>     for (StudentClass studentClass : studentClassList) {
>         if (studentList.studentNo == studentClass.studentNo) {
>             // 连接加入ansList中
>             break;
>         }
>     }
> }
> ```



**排序-合并算法（Sort-Merge Join 或 Merge-Join）**

1. 如果连接的表没有排好序，先对 `student` 表和 `student_class` 表按连接属性 `student_no` 排序。
2. 取 `student` 表中第一个 `student_no`，依次扫描 `student_class` 表中具有相同 `student_no` 的元组。
3. 当扫描到 `student_no` 不相同的第一个 `student_class` 元组时，返回 `student` 表扫描它的下一个元组，再扫描 `student_class` 表中具有相同 `student_no` 的元组，把它们连接起来。

> 即大概的流程如下：比如现在 `student` 表中有三个元组，`student_no` 分别为1,2,3，`student_class` 表中有六个元组，分别为1,1,2,3,3,3。则先排序（这里已经排序好了），然后扫描`student` 的第一个元组，得到 `student_no = 1`，然后扫描 `student_class`，前两个元组的 `student_no` 都相同，扫描到 `student_no = 2` 时，因为与 `student` 表中取出的 `student_no` 不同，则返回 `student` 表，然后取下一个 `student_no = 2`，然后回到 `student_class` 取下一个， `student_no = 2`。如此遍历下去即可。

优点：

* `student` 表和 `student_class` 表都只要扫描一遍
* 如果两个表原来无序，执行时间要加上对两个表的排序时间
* 对于大表，先排序后使用排序-合并连接算法执行连接，总的时间一般仍会减少



**索引连接（Index Join）算法**：

1. 在 `student_class` 表上已经建立属性 `student_no` 的索引
2. 对 `student` 中的每一个元组，由 `student_no` 值通过 `student_class` 的索引查找相应的 `student_class` 元组。
3. 把这些 `student_class` 元组和 `student` 元组连接起来。
4. 循环执行第二步和第三步，直到 `student` 表中的元组处理完为止。



**Hash Join算法**

1. 把连接属性作为hash码，用同一个hash函数把 `student` 表和 `student_class` 表中的元组散列到hash表中
2. 划分阶段（building phase, 也称为 partitioning phase）
	* 对包含较少元组的表（`student` 表）进行一遍处理
	* 把它的元组按hash函数分散到hash表的桶中
3. 试探阶段（probing phase, 也称为连接阶段 join phase）
	* 对另一个表（`student_class` 表）进行一遍处理
	* 把 `student_class` 表的元组也按同一个hash函数（hash码是连接属性）进行散列
	* 把 `student_class` 元组与桶中来自 `student` 表并与之相匹配的元组连接起来。

Hash Join算法的前提：假设两个表中较小的表在第一阶段后可以完全放入内存的hash桶中。



## 32 查询优化

**关系系统的查询优化**：

* 是关系数据库管理系统实现的关键技术又是关系系统的优点所在
* 减轻了用户选择存取路径的负担

关系查询优化是影响关系数据库管理系统性能的关键因素

由于关系表达式的语义级别很高，使关系系统可以从关系表达式中分析查询语义，提供了执行查询优化的可能性

**非关系系统的查询优化**：

* 用户使用过程化的语言表达查询要求，执行何种记录级的操作以及操作的序列是由用户来决定的。
* 用户必须了解存取路径，系统要提供用户选择存取路径的手段，查询效率由用户的存取策略决定。
* 如果用户做了不当的选择，系统是无法对此加以改进的。



**查询优化的优点**：

* 用户不必考虑如何最好地表达查询以获得较好的效率
* 系统可以比用户程序的“优化”做得更好
	* 优化器可以从数据字典中获取许多统计信息，而用户程序则难以获得这些信息。
	* 如果数据库的物理统计信息改变了，系统可以自动对查询重新优化以选择相适应的执行计划。在非关系系统中必须重写程序，而重写程序在实际应用中往往是不太可能的。
	* 优化器可以考虑数百种不同的执行计划，程序员一般只能考虑有限的几种可能性。
	* 优化器中包括了很多复杂的优化技术，这些优化技术往往只有最好的程序员才能掌握。系统的自动优化相当于使得所有人都拥有这些优化技术。



**查询优化的总目标**

* 关系数据库管理系统通过某种代价模型计算出各种查询执行策略的执行代价，然后选取代价最小的执行方案
	* 集中式数据库
		* 执行开销主要包括：磁盘存取块数（I/O代价） + 处理机时间（CPU代价） + 查询的内存开销
		* I/O代价是最主要的
	* 分布式数据库
		* 总代价=I/O代价+CPU代价+内存代价＋通信代价
* 查询优化的总目标
	* 选择有效的策略
	* 求得给定关系表达式的值
	* 使得查询代价最小（实际上是较小，因为需要权衡多因素，不可能达到最完美）
* 一个关系查询可以对应不同的执行方案，其效率可能相差非常大。



## 33 代数优化

代数优化策略：通过对关系代数表达式的等价变换来提高查询效率

关系代数表达式的等价：指用相同的关系代替两个表达式中相应的关系所得到的结果是相同的

两个关系表达式 $E_1$ 和 $E_2$ 是等价的，可记为 $E_1 \equiv E_2$



**常用的等价变换规则**

1. 连接、笛卡尔积交换律：
2. 连接、笛卡尔积结合律
3. 投影的串接定律
4. 选择的串接定律
5. 选择与投影操作的交换律
6. 选择与笛卡尔积的交换律
7. 选择与并的交换律
8. 选择与差与运算的分配律
9. 选择对自然连接的分配律
10. 投影与笛卡尔积的分配律
11. 投影与并的分配律

![image-20220512113146242](https://img-bed-1309306776.cos.ap-shanghai.myqcloud.com/img/image-20220512113146242.png)

![image-20220512113420298](https://img-bed-1309306776.cos.ap-shanghai.myqcloud.com/img/image-20220512113420298.png)

![image-20220512113440476](https://img-bed-1309306776.cos.ap-shanghai.myqcloud.com/img/image-20220512113440476.png)

![image-20220512113501505](https://img-bed-1309306776.cos.ap-shanghai.myqcloud.com/img/image-20220512113501505.png)

**典型的启发式规则**

1. 选择运算尽可能先做：这是在优化策略中最重要、最基本的一条
2. 把投影和选择运算同时进行：若有若干投影和选择运算，并且它们都对同一个关系操作，则可以在扫描此关系的同时完成所有的这些运算以避免重复扫描关系。
3. 把投影同其前或其后的双目运算结合起来：没有必要为了去掉某些字段而扫描一遍关系。
4. 把某些选择同在它前面要执行的笛卡尔积结合起来成为一个连接运算：连接特别是等值连接运算要比同样关系上的笛卡尔积省很多时间。
5. 找出公共子表达式
	* 如果这种重复出现的子表达式的结果不是很大的关系，并且从外存中读入这个关系比计算该子表达式的时间少得多，则先计算一次公共子表达式并把结果写入中间文件是合算的
	* 当查询的是视图时，定义视图的表达式就是公共子表达式的情况

### 33.1 查询树的启发式优化

遵循这些启发式规则，应用等价变换公式来优化关系表达式的算法。

* 算法：关系表达式的优化
* 输入：一个关系表达式的查询树
* 输出：优化的查询树
* 方法：利用等价变换规则



## 34 物理优化

代数优化改变查询语句中操作的次序好组合，不涉及底层的存取路径。对于一个查询语句有许多存取方案，它们的执行效率不同，仅仅进行代数优化是不够的。物理优化就是要选择高效合理的操作算法或存取路径，求得优化的查询计划。

**物理优化方法**

* 基于规则的启发式优化：启发式规则是指那些在大多数情况下都适用，但不是在每种情况下都是最好的规则。
* 基于代价估算的优化：优化器估算不同执行策略的代价，并选出具有最小代价的执行计划。
* 两者结合的优化办法：
	* 常常先使用启发式规则，选取若干较优的候选方案，减少代价估算的工作量。
	* 然后分别计算这些候选方案的执行代价，较快地选出最终的优化方案。



### 34.1 启发式规则

**选择操作的启发式规则**

对于小关系，使用全表顺序扫描，即使选择列上有索引。

对于大关系，启发式规则有：

1. 对于选择条件是 **主码 = 值** 的查询：
	* 查询结果最多是一个元组，可以选择主码索引
	* 一般的关系数据库管理系统会自动建立主码索引。
2. 对于选择条件是 **非主属性 = 值** 的查询，并且选择列上有索引：
	* 要估算查询结果的元组数目：
		* 如果比例较小，可以使用索引扫描方法
		* 否则还是使用全表顺序扫描
3. 对于选择条件是属性上的**非等值查询**或**范围查询**，并且选择列上有索引：
	* 要估算查询结果的元组数目：
		* 如果比例较小，可以使用索引扫描方法
		* 否则还是使用全表顺序扫描
4. 对于用 `AND` 连接的合取选择条件：
	* 如果有设计这些属性的组合索引：优先采用组合索引扫描方法。
	* 如果某些属性上有一般的索引，可以用索引扫描方法：
		* 通过分别查找满足每个条件的指针，求指针的交集
		* 通过索引查找满足部分条件的元组，然后在扫描这些元组时判断是否满足剩余条件。
	* 其他情况：使用全表顺序扫描
5. 对于用 `OR` 连接的析取选择条件，一般使用全表顺序扫描。



**连接操作的启发式规则**

1. 如果2个表都已经按照连接属性排序
	* 选用排序-合并算法
2. 如果一个表在连接属性上有索引
	* 选用索引连接算法
3. 如果上面2个规则都不适用，其中一个表较小
	* 选用hash join算法
4. 可以选用嵌套循环方法，并选择其中较小的表，确切地讲是占用的块数(B)较少的表，作为外表(外循环的表) 。
	* 理由：
		* 设连接表 `R` 与 `S` 分别占用的块数为 `Br` 与 `Bs`，连接操作使用的内存缓冲区块数为 `K`，分配 `K-1` 块给外表，如果 `R` 为外表，则嵌套循环法存取的块数为 $Br+\frac{Br \times Bs}{K-1}$
		* 显然应该选块数小的表作为外表



## Reference

1. [数据库系统概论（第五版）](https://book.douban.com/subject/26317662/)
2. [数据库系统概念](https://book.douban.com/subject/10548379/)
2. 南京大学软件学院2022春季学期数据管理基础课程
