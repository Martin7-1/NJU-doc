# OOC-Review

## 1 OO基础

### 1.1 从过程化到面向对象

#### 1.1.1 外部质量因素

1. Correctness 正确性：依据规约 完成任务
2. Robustness 鲁棒性：异常情况 合理反映
3. Integrity 完整性：非法访问或修改 合理反映
4. Extendilibity 易扩展性：软件产品应 规约改变 而 改变
5. Resusability 易复用性：软件模块 用于构建多种不同应用
6. Compatibility 兼容性：软件模块相互组合的难易
7. Efficiency 高效性：尽量少地使用硬件资源、处理器时间、内存、外存、网络带宽等
8. Portability 易移植性：转换到不同的软硬件平台上
9. Ease of use 易用性：不同背景的用户学习使用软件产品解决问题的难易

初次之外，外部质量因素主要考虑下面三个方面：

* Functionality：功能
* Timeliness：按时交付
* Verifiability，Reparability，Economy：可验证性、可修复型、经济性

#### 1.1.2 应对复杂性

> 复杂性是软件开发过程中所固有的特质

应对复杂性的基本途径：

1. 分解Decomposition：分而治之
2. 抽象Abstraction：抓本质、抓重点
3. 层次话Hierarchy：应对大系统，纲举目张

**结构化开发方法**

按照一定的原则与原理，组织和编写正确且易读的程序的软件技术，主要思想是自顶向下、逐步求精。

#### 1.1.3 模块化

模块化是软件构造为一组“模块”之有序组合，从而易于装配、易于修补替换模块。模块化是扩展性和易复用性的要求。模块化的方法有以下的五个目标和五个规则：

**五个目标**

1. Decomposability 易分解性：复杂的问题分解成多个子问题
2. Composability 易组合性：软件单元可以自由组合进而生成新的软件
3. Understandability 易理解性：模块应该可以被单独理解
4. Continuity 连续性：规约中的小变化也只会引起结构的小变化
5. Protection 保护性：异常不扩散或者扩散的范围是有限的

**五个规则**

1. Direct Mapping 直接映射
2. Few Interfaces 接口要少
3. Small Interfaces 接口要小：接口应该只获得需要的信息
4. Explicit Interfaces 接口要明确
5. Information Hiding 信息隐蔽：通过 `public` 接口和外界交互，其他都属于秘密，外界无法获得

模块的根本特征是“相对独立，功能单一”。换言之，一个好的模块必须具有高度的独立性和相对较强的功能。

**耦合度和内聚度**

* 耦合度，是指模块之间相互依赖性大小的度量，耦合度越小，模块的相对独立性越大
* 内聚度，是指模块内各成分之间相互依赖性大小的度量，内聚度越大，模块各成分之间联系越紧密，其功能越强。

在模块划分当中应该做到“耦合度尽量小，内聚度尽量大”（高内聚、低耦合）

#### 1.1.4 面向对象开发方法

**面向对象的基本思想**

1. 任何事物都是对象，对象有属性和方法。复杂对象可以由相对简单的对象以某种方式构成
2. 通过类比发现对象间的相似性，即对象间的共同属性，是构成对象类的依据
3. 对象间的互相联系是通过传递“消息”来完成的。通过对象之间的消息通信驱动对象执行一系列的操作从而完成某一任务

**基本概念**：对象、类、封装性、继承性、多态性、动态绑定、消息传递

### 1.2 抽象数据类型

#### 1.2.1 Overview

* 基于过程的抽象：指任何一个明确定义功能额度操作都可以被使用者看作单个的实体，尽管这个操作实际可能由一系列更低级的操作完成
* 基于数据的抽象：定义了数据类型和施加于该类型对象上的操作，并限定了对象的值只能通过这些操作修改和观察。包含了2个概念：
  * 模块封装
  * 信息隐藏

数据抽象提供了面向对象计算的起点：系统应该被分解为概念上的实体，实体的内部细节应该被隐藏

#### 1.2.2 Abstract Data Type

抽象数据类型（ADT）：用<span style='color: red'>**数学方法**</span>定义对象集合和运算集合，仅通过运算的性质刻画数据对象，而独立于计算机中可能的表示方法

ADT规约方法：**代数方法**

1. 语法部分
   * ADT名
   * 运算（函数）的定义域和值域
2. 公理部分
   * 给出一组刻画各运算之间相互关系的方程来定义各运算的含义
   * **语义正确性**：相应代数满足规约中公理部分的所有公理

![ADT-Stack](https://img-bed-1309306776.cos.ap-shanghai.myqcloud.com/img/ADT-Stack.png)

![ADT-Function](https://img-bed-1309306776.cos.ap-shanghai.myqcloud.com/img/ADT-Function.png)

**ADT函数分类**

一个ADT T中可以有三种函数（算子）：

1. Creators（构造算子）： $OTHER \rightarrow T$  e.g.new
2. Queries（观察算子）：$T \times ... \rightarrow \ OTHER$ e.g.item, empty
3. Commands（运算算子）：$T \times ... \rightarrow \ T$ e.g.put, remove

> 偏函数（Partial Functions），在ADT中用箭头加一个斜杠表示（即remove和item）。
>
> 偏函数是一种可能没有定义所有可能的参数的函数（即可能会有默认的参数），这样做是为了减少重复的参数传递，提高函数的适用性以及固定执行环境的上下文
> 
> 1. 对于 `item` 来说，其语义是“获得栈最顶层的元素”，这里就省略了给 `item` 传递元素位置 -- 最顶层 这个参数，因为这个参数是默认的，而且是符合栈的结构的，如果定义为可以让使用者传递参数，那么使用者随意传参来获取某个位置的元素就会导致 Stack 失去原有的信息隐藏性。
> 2. 对于 `remove` 来说，其语义是“删除栈最顶层的元素”，和 `item` 同理，也是省略了传递参数位置 -- 最顶层 这个参数，也是为了遵守 Stack 这个 ADT 的规约和信息隐藏，只能够对最顶层的元素进行操作（这里的 `remove` 其实就是 `pop`）

![ADT-Stack-Cond](https://img-bed-1309306776.cos.ap-shanghai.myqcloud.com/img/ADT-Stack-Cond.png)

![ADT-Stack-complete](https://img-bed-1309306776.cos.ap-shanghai.myqcloud.com/img/20220611214633.png)

**总结**

使用代数方法定义一个 ADT 的时候，需要有以下几个内容以及注意的点：

1. 首先是 ADT 的名字（TYPES，如果其是像 Stack 这种存储元素的列表，对于未定义的元素类型可以用类似泛型的参数定义）
2. 其次是 ADT 的函数部分，包含了该 ADT 能够支持的操作
3. ADT 的公理部分，需要定义一些在 ADT 中**最为基础**的行为，从而能够根据公理推出其他的任何代数表达式
4. 最后是 ADT 的前置条件，这是针对一些函数所需要的，比如要求非空等。

**注意点**

1. 注意某些函数定义时是使用偏函数还是正常的函数
2. 注意前置条件的考虑
3. 注意代数运算时需要满足的公理的考虑（即需要考虑如何定义最基本的运算含义）
4. ADT一致性：当且仅当对于任何格式良好的查询表达式 e，公理使得最多可以推断出 e 的一个值时，ADT 规范才是一致的。

#### 1.2.3 ADT and software architecture

* 找到所有的抽象数据类型的模块：使用抽象数据类型的实现来标识每个模块，即具有公共接口的一组对象的描述。
* 定义抽象数据类型中的操作以及定理：接口由一组操作（实现 ADT 的功能）定义，这些操作受抽象属性（公理和前提条件）的约束。
* 具体实现：该模块由抽象数据类型的表示形式和每个操作的实现组成。辅助操作也可能包括在内。

#### 1.2.4 信息隐蔽原则

使用 ADT 的程序应该只依赖于它的规约保证的性质，而不依赖于它的任何特定实现。即对于某一个 ADT 来说，使用者只需要遵守它的规约保证的性质，而不需要知道该 ADT 在内部是如何实现的。

### 1.3 契约式设计

// todo