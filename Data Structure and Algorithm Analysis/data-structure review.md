# 数据结构重点

## 排序

1. 不考：希尔排序，二分插入排序，表排序，竞标赛排序不考
2. 容易考：插排，冒泡排序，选排，快排，归并排序，堆排序
3. 有题不多

## 图

1. AOE
2. 基本概念，算法概念：最小生成树算法/最短路径算法
3. 邻接多重表不考
4. 图的遍历（DFS，BFS）

## 并查集

记得没考，可能只是混在后面用，最小生成树算法中所用到的并查集

## 优先级队列/堆

1. 堆 -- 上滤/下滤/堆排序

## 散列表

1. 双散列/特殊散列
2. 线性探测法常考
3. 二次探测法不常考
4. 分离链接法常考
5. 再散列

## 树

1. 树的概念不单独考
2. 树根第一层开始：树根高度为1. 树根第0层开始：树根高度为0
3. 二叉树的数组表示 -- 堆
4. 二叉树的链接表示 重点
5. 二叉树的遍历 -- 先序/中序/后序/层次
6. 广义表不考
7. 后缀表示不考
8. 先序 + 中序来构建二叉树
9. 树的表示法：左子女-右兄弟为重点
10. 左子女-右兄弟的先根/后根/中根
11. 线索化二叉树
12. 霍夫曼树
13. 二叉搜索树 + AVL树
14. m路搜索树 + B树
    * B树不考代码 -- 画B树插节点删节点

### m-路搜索树
> m-路搜索树是B-Tree的一个基础

#### m-路搜索树的性质

1. m-路搜索树的内节点最多有m个子节点，节点内最多有m-1个关键码，且这些关键码按大小排列
2. 有 $p$ 个关键码节点一定会有 $p+1$ 个子节点
3. m-路搜索树的一个节点可以表示成如下的形式
    * $C_0k_1C_1k_2 \dots k_pC_p$
    * 其中 $C_0$ 是一个指向子节点的指针，且其中的值要全部小于 $k_1$
    * $C_i$ 指向的子节点的值需要全部大于 $k_i$ 且全部小于 $k_{i+1}$
    * $C_p$ 指向的子节点的值需要全部大于 $k_p$ 里的值 

#### m-路搜索树的搜索

思路：和二叉搜索树相同，但在某个节点里我们需要遍历到前一个关键码小于要搜索的值，后一个关键码大于要搜索的值，然后在两个关键码之间的子节点继续递归搜索，直到我们搜索到外部节点或者我们找到了该节点

#### m-路搜索树的插入

思路：同理，我们需要遍历到前一个关键码小雨要插入的值，后一个关键码大于要搜索的值，然后在两个关键码之间的子节点继续递归向下到叶节点，如果叶节点的关键码数量没满 $m$，那么我们直接插入即可

如果叶节点的关键码数量已经是 $m$ 了，那么我们可以将该节点的中间值拉到父节点，然后将该节点拆成两半，如果父节点的关键码也已经满了（即我们没办法将该该节点的中间拉到父节点），那么我们应该先处理父节点，现将父节点的中间值拉到父节点的父节点，然后分裂，即我们应该如此递归下去。这种做法在后面B-Tree的插入中也是十分常见的，这也是B-Tree唯一有可能增加树高的方式，请注意，B-Tree增加树高是自底向上的，即增加树高的方式是根节点再一次往上拉取一个节点，导致高度加一。

同时我们需要注意，m-路搜索树并不一定要求所有外部节点在同一层，这意味着当某个叶子节点已经满了之后，我们可以通过增加子节点来存放新的节点，而不是用上面这种"分裂"的方式

#### m-路搜索树的删除

思路：直接删除即可，如果不是删除叶子节点，我们和二叉搜索树一样，也需要从其左边指针的子树中找到一个值最大的节点替代当前节点，然后删除那个节点即可。对于某个删除后空出来的节点或因为上述操作移动而导致空出来的节点，我们需要同理找到左指针指向的子树中值最小或者右指针指向的子树中值最大的值来替换，如此递归到叶子节点即可。注意：m-路搜索树的删除如果导致某个外部节点的消失并不影响。
    
### B树

#### B树的性质

1. B-Tree的所有叶子节点都在同一层
2. B-Tree有"阶"的定义，几阶限定了B-Tree的每个节点里关键码的数量和外节点的数量
3. 除了树根的其他节点必须要包含至少 $t/2 - 1$ 个关键码（key），这里的 $t$ 是B-Tree的阶数，除法需要向上取整，即每个节点至少要包含 $t/2$ 个子节点（根节点除外）
4. 同时B-Tree也是一个m-路搜索树，也就是说每个节点中的关键码个数不能多于m（在B-Tree中用阶来定义）
5. 根节点至少有两个子节点
6. 外部节点的个数 = 关键码个数 + 1

#### B-Tree的查找

思路：与m-路搜索树相同，我们只需要找到前一个关键码的值小于我们要搜索的值，后一个关键码的值大雨我们要搜索的值，两个值中间的指针指向的子节点就是我们要前往下一层的节点，然后递归的寻找即可。时间复杂度为 $O(h)$，h为B-Tree的高度。在磁盘中，由于B-Tree的"fat"，这个高度不会很高

关于B-Tree的高度：

#### B—Tree的插入

B—Tree的插入永远发生在位于外部节点上一层的节点中，且有以下几种情况发生
1. 要插入的节点中关键码的数量小于 $m-1$，按大小排序直接插入该节点即可
2. 要插入的节点中关键码的数量等于 $m$，则我们需要将当前节点进行一个分裂，并将 $k_{\frac{m}{2}}$ 的关键码拉到父节点（这里的除法是 $m/2$ 向上取整）。如果父节点的关键码也满了，那么我们就递归分裂并向上移动关键码。如果root的关键码也是满的，那么这样递归向上会造成B—Tree的高度加一，这也是唯一的能够增加B-Tree高度的方式。当然，思考之后我们就会知道，其实能够到如此地步的概率一般是十分小的，在真实磁盘中的B-Tree的阶数一般都十分的大，即分裂一次之后我们可以在新的节点中存储很多的节点，因此不太有可能造成B—Tree的高度增加。即使高度增加了，那么下一次增加肯定会发生很久以后，因为此时我们有很多分裂的节点可以让我们插入新的节点。

节点的插入最多引起的磁盘访问量是 $h + 2s + 1$，h是树高，s是分裂的节点数量（需要写入分裂后的节点到磁盘），剩下1是写入新的节点


#### B-Tree的删除

B-Tree的删除有两种情况：
1. 删除的关键码所在节点的子节点是一个外部节点，即删除的关键码在叶子节点中
2. 删除的关键码所在节点不是叶节点。

##### Case 1

1. 若删除该关键码之后该节点的关键码个数仍然大于 $\frac{m}{2} - 1$（这里的除法要向上取整），那么我们就直接删除该关键码即可
2. 如果不满足上述的情况，那么我们需要进行一个"借"的操作。对于一个关键码个数刚好是 $\frac{m}{2} - 1$的节点进行删除，我们可以向邻居借关键码，并进行一定的调整。


## 栈与队列

1. 巧妙方式使用栈与队列

## 线性表

1. 双向链表不考
2. 循环链表 -- 考
3. 约瑟夫问题不考

## 算法分析

1. 复杂度分析
