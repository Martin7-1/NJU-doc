# DBManagementReview

## 关系代数

## SQL

## E-R图

## 范式

### 函数依赖

定义：设 $R(U)$ 是属性集 $U$ 上的关系模式，$X$，$Y$ 是 $U$ 的子集。若对于 $R(U)$ 的任意一个可能的关系 $r$，$r$ 中不可能存在两个元组在 $X$ 上的属性值相等，而在 $Y$ 上的属性值不等，则称 $X$ 函数确定 $Y$ 或者 $Y$ 函数依赖于 $X$，记作 $X \rightarrow Y$

#### 非平凡函数依赖

$X \rightarrow Y$，但 $Y \nsubseteq X$，则称 $X \rightarrow Y$ 是非平凡的函数依赖

#### 完全函数依赖

在 $R(U)$ 中，如果 $X \rightarrow Y$，并且对于 $X$ 的任意一个真子集 $X'$，都有 $X' \nrightarrow Y$ 则称 $Y$ 对 $X$ 完全函数依赖，记作 $X \stackrel{F}{\rightarrow} Y$

#### 部分函数依赖

若 $X \rightarrow Y$，但 $Y$ 不完全函数依赖于 $X$，则称 $Y$ 对 $X$ 部分函数依赖

#### 传递函数依赖

在 $R(U)$ 中，如果 $X \rightarrow Y(Y \nsubseteq X), Y \nrightarrow X, Y \rightarrow Z, Z \nsubseteq Y$，则称 $Z$ 对 $X$ 传递函数依赖

### 第一范式1NF

定义：每一个分量必须时不可分的数据项，满足了这个条件的关系模式就属于第一范式（1NF）

> 例如 Employee 表中的 address 属性可以细分为 city, street, postcode，那么该关系表是不符合1NF的。对原子性的要求通常随实际业务而变化，因此无需过于纠结 1NF，直接将其作为基本假定进行分析即可。

#### 问题

1. 数据冗余
2. 更新异常
3. 插入异常
4. 删除异常

### 第二范式2NF

定义：若 $R \in 1NF$，且每一个非主属性完全函数依赖于任何一个候选码，则 $R \in 2NF$（即2NF消除了部分函数依赖）

> 在关系 $R{A B C D}$ 中存在依赖 $AB \rightarrow C, B \rightarrow D$，易知唯一的键是 $AB$ ，但属性 $D$ 依赖于键 $AB$ 的一部分 $B$（即部分依赖），因此违背 2NF。如果没有 $B \rightarrow D$，则满足 2NF。

#### 问题

如果一个关系模式不属于2NF，会产生以下的问题

1. 数据冗余
2. 修改复杂，更新异常
3. 插入异常
4. 删除异常

采用了2NF之后，对数据冗余和更新异常有所改进，但是仍然有插入异常和删除异常

### 第三范式3NF

定义：设关系模式 $R(U,F) \in 1NF$，若 $R$ 中不存在这样的码 $X$，属性组 $Y$ 及非主属性 $Z(Z \nsubseteq Y)$ 使得 $X \rightarrow Y, Y \rightarrow Z$ 成立，$Y \nrightarrow X$，则称 $R(U,F) \in 3NF$。（即3NF消除了非主属性的传递依赖和部分依赖）

> 举一个满足 2NF 但不满足 3NF 的例子：在关系 $R{A B C D}$ 中存在依赖 $A \rightarrow BC, BC \rightarrow D$，易知唯一键是 $A$ ，$BC$ 为非主属性，存在由 $A$ 到 $BC$ 到 $D$ 的传递依赖，因此不满足3NF。

#### 问题

如果一个关系模式不属于3NF，会产生以下的问题

1. 数据冗余
2. 更新异常
3. 插入异常
4. 删除异常

采用了3NF之后，对数据冗余、插入异常、删除异常都是有改进的

### BCNF

定义：关系模式 $R(U,F) \in 1NF$，若 $X \rightarrow Y$ 且 $Y \nsubseteq X$ 时 $X$ 必含有码，则 $R(U,F) \in BCNF$（即BCNF中的所有函数依赖的决定因素都是包含码的，BCNF消除了主属性的传递依赖和部分依赖）

#### 问题

使用了BCNF之后，消除了插入异常和删除异常

## 事务

## 并发

## NoSQL

### 键值数据库

#### 存什么

键值数据库（key-value store）是一张简单的哈希表，主要用在所有数据库访问均通过主键（primary key）来操作的情况下。

* 可以把此表想象成传统的“关系”，该关系仅仅只有两列：ID与NAME
* ID列代表关键字，NAME存放之。NAME列仅能存放**String**类型的数据
* 应用程序可提供ID及VALUE值，并将这一键值对持久化
* 加入ID已存在，就用新值覆盖当前值，否则就新建一条数据

> 客户端可以根据键查询值，设置键所对应的值，或者从数据库中删除键
> 
> * “值”只是数据库存储的一块数据而已，它不关心也无需知道其中的内容
> * 应用程序负责理解所存数据的含义
> 
> 键值数据库并不关心键值对里的值，它可以是二进制块、文本、JSON、XML等

#### 适合存什么

1. 存放会话信息：网络会话是唯一的，分配给它们的seesionId值也各不相同，所以可以将sessionId作为键值来存放，全部的会话内容就可以通过一条PUT请求来存放，而只需要通过一条GET请求就可以获得
2. 存放用户配置信息/产品信息：用户配置信息包含一些独立的配置信息（比如id、username或者其他独特的属性），存放在键值数据库中可以通过一次GET操作即获取某位用户的全部配置信息
3. 存放购物车数据：购物车内容要在不同时间、不同浏览器、不同电脑、不同会话中保持一致，所以可以把购物信息放在value中，并将其绑定到userId这个键名中。

#### 不适合存什么

1. 数据间关系：即将不同键值集合联系起来
2. 含有多项操作的事务
3. 查询数据：根据键值对的**部分值**来搜寻关键字，那么键值数据库就不是很理想的，无法直接检视键值数据库中的值
4. 操作关键字集合：操作多个关键字最好在客户端处理（键值数据库一次只能操作一个键）

### 文档数据库

#### 存什么

文档（document）是文档数据库中的主要概念

* 其格式可以是XML、JSON、BSON等
* 文档具备自述性（self-describing），呈现分层的树状数据结构（hierarchical tree data structure），可以包含映射表、集合和标量值

文档彼此相似，但不必完全相同。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。文档数据库可视为**其值可查**的键值数据库。

文档数据库中，放在同一“集合”内的各文档的“数据模式”（the schema of the data）可以不同。

> 关系型数据库中，表格中每行数据的模式都要相同。

文档中可以嵌套数组等基本数据类型，也可以将“子文档”（child document）以“子对象”(subobject) 的形式嵌入主文档。由于没有“数据模式”约定，文档数据库的文档中无需空属性，若其中不存在某属性，就假定该属性值未设定或与此文档无关。向文档中新增属性时，既无需预先定义，也不用修改已有文档内容。

> 关系型数据库中，需要定义表中的每一列，而且若某条记录中的某列没有数据，则要将其留空(empty) 或设为null。

#### 适合存什么

1. 事件记录：企业级解决方案中，许多不同的应用程序都需要记录事件。应用程序对事件记录各有需求
2. 其他：
   1. 内容管理系统及博客平台：文档数据库没有预设模式，而且支持JSON文档，所以可以用在“内容管理系统”及网站发布程序上，也可以用来管理用户评论、用户注册、用户配置和面向Web文档
   2. 网站分析与实时分析：文档数据库可以存储实时分析数据。由于可以只更新部分文档内容，所以用它来存储“页面浏览量”（page view）或者“独立访客数”（unique visitor）会非常方便，无需改变模式即可新增度量标准
   3. 电子商务应用程序：需要灵活模式存储订单和产品，需要不做高成本数据库重构及数据迁移的前提下进化其数据模型

#### 不适合存什么

1. 包含多项操作的复杂事务
2. 查询持续变化的聚合结构

### 列族数据库

#### 存什么

列族数据库可以存储关键字及其映射值，并且可以把值分成多个了列族，让每个列族代表一张数据映射表（map of data）。

列族数据库将数据存储在列族中，而列族里的行则把许多列数据与本行的“行键”（row key）关联起来

![列族数据库](https://img-bed-1309306776.cos.ap-shanghai.myqcloud.com/img/20220620150535.png)

Cassandra（一款流行的列族数据库）的基本存储单元为“列”，列由一个“名值对“（name-value pair）组成，其中的名字也充当关键字。

每个键值对都占据一列，并且都存有一个“时间戳”值。令数据过期、解决写入冲突、处理陈旧数据等操作都会用到时间戳。若某列数据不再使用，则数据库可于稍后的“压缩阶段”（compaction phase）回收其所占空间。

行是列的集合，这些列都附在某个关键字名下，或与之相连。由相似行所构成的集合就是列族。

> 每个列族都可以与关系型数据库的“行容器”（container of rows）相对照:
> 
> * 两者都用关键字标识行，并且每一行都由多个列组成。
> * 其差别在于，列族数据库的各行不一定要具备完全相同的列，并且可以随意向其中某行加入一列，而不用把它添加到其他行中

列族数据库中的两种列：

1. “标准列族”（standard column family）中的列都是“简单列”（simple column）。
2. “超列族”（super column family）：
   1. 如果某列中包含一个由小列组成的映射表，那么它就是“超列”（super column）。可将超列视为“列容器”（container of columns）。
   2. 用超列构建的列族叫做“超列族” 。
   3. 超列族适合将相关数据存在一起。但是，如果部分列在大部分情况下都用不到，则存在不必要的开销。

“键空间”（keyspace）与关系型数据库中的“数据库”类似，与应用程序有关的全部列族都存放于此。必须先创建键空间，才能为其增添列族

#### 适合存什么

1. 事件记录：由于列族数据库可存放任意数据结构，所以它很适合用来保存应用程序状态或运行中遇到的错误等事件信息。列族数据库的写入能力可扩展，所以在事件记录系统中用它的效果会很好
2. 内容管理系统与博客平台：使用列族可以把博文中的“标签”（tag）、“类别”（category）、“链接”（link）和“trackback”日等属性放在不同的列中
3. 其他
   1. 计数器：统计某页面的访问人数并对其分类，以算出分析数据
   2. 限期：可能需要向用户提供试用版，或是在网站上将某个广告条显示一定时间。这些功能可以通过“带过期时限的列”（expiringcolumn）来完成。

#### 不适合存什么

1. 需要以“ACID事务”执行写入以及读取操作的系统
2. 让数据库根据查询结果来聚合数据的场景

### 图数据库

#### 存什么

* 图数据库可存放实体及实体间关系。
* 实体也叫“节点”（node），它们具有属性（property）。可将节点视为应用程序中某对象的实例。
* 关系又叫“边”（edge），它们也有属性。边具备方向性（directional significance），而节点则按关系组织起来，以便在其中查找所需模式。
* 用图将数据一次性组织好，稍后便可根据“关系”以不同方式解读它。

![图数据库](https://img-bed-1309306776.cos.ap-shanghai.myqcloud.com/img/20220620152140.png)

> 注意关系（即边）是有方向的，同时关系也可能有自己的属性

#### 适合存什么

1. 互联数据：富含链接关系的领域都很适合用图数据库来表示
2. 安排运输路线、分派货物和基于位置的服务
3. 推荐引擎

#### 不适合存什么

1. 更新全部或者某个子集内的实体时也许不适用
2. 涉及整张图的操作很多的场景

