# 图

## 定义

$$
Graph = (V, E)
$$

$V$：非空有穷的顶点集合

$E$：边的集合，顶点的二元关系



### 无向图

$$
(v_2, v_1) = (v_1, v_2)
$$

### 有向图

$$
(v_2, v_1) \ne (v_1, v_2)
$$

> 起点在前，终点在后

---



## 概念

### 完全图

一张图里有 $n$ 个顶点，且有 $\frac{n(n-1)}{2}$ 条边，则该图称为<span style='color: red'>**无向完全图**</span>

一张图里有 $n$ 个顶点，且有 $n(n-1)$ 条边，则该图称为<span style='color: red'>**有向完全图**</span>



### 图的度数

某个顶点相连的边的总数被称为该顶点的度数 -- 无向图

入边（以该顶点为终点）/出边（以该顶点为起点），入度 + 出度 = 度数 -- 有向图

> 一张图的边数等于图中所有顶点度数之和除以2
> $$
> e = \sum_{i=1}^{n} TD(v_i) / 2
> $$



### 子图

在原图的基础上选择一些点和一些边，并确保表示这些边的顶点只能够在这些点之间。

### 路径

#### 简单路径

不存在回路的路径，即除了起点和终点，中间经过的点都是不相同的

#### 简单回路

起点和终点相同的简单路径



### 连通图

无向图：极大连通子图（连通分量）

#### 有向图的连通图

强连通：任意两个顶点之间既能够走过去，也能够走回来。
$$
\forall i, j, (v_i, v_j) \in E \and (v_j, v_i) \in E
$$
极大强连通子图（强连通分量，SCC）：非强连通图中的一个强连通的子图，再增加一个节点就不强连通。



### 权重图

加权连通图/加权强连通有向图：网络

### 生成树（Spanning Tree）

连通图的极小连通子图，$n$ 个顶点只有 $n - 1$ 条边（即重复去边，直到再去掉一条边这个图就不连通）

> TIPS: 生成树不唯一

---



## 图的物理结构

### 邻接矩阵（Adjacency Matrix）

对一个 $n$ 个顶点的图 $G = (V,E)$，邻接矩阵是一个 $n \times n$ 的矩阵，若在图中存在一条边 $(v_i, v_j)$，则把矩阵中的 $(i, j)$（若无向图则应该将 $(j, i)$ 也置为 $1$） 置 $1$，其他置 $0$。 

> 无向图中邻接矩阵是对称的
>
> 顶点 $i$ 的度数为邻接矩阵的第 $i$ 行的值之和 -- 无向图
>
> 顶点 $i$ 的度数为邻接矩阵的第 $i$ 行（出度） + 第 $i$ 列（入度）的值之和 -- 有向图

对加权图来说：

邻接矩阵的值变成边的权重，若没有边则在邻接矩阵中用 $\infin$ 记录（无法用 $0$ 表示）

### 邻接表（Linked-adjacency Lists）

> 顶点多，边少的情况下可以节省内存

#### 无向图

多条单链表组成，$n$ 个顶点有 $n$ 个链表，单链表里记录终点顶点，单链表节点数 = 边的数量的两倍。每条链表记录以某个节点为起点的所有边。

#### 有向图

$n$ 个顶点有 $n$ 个链表，链表里记录终点（若有权重还记录权重），单链表节点数 = 边的数量

> 也可以用逆邻接表，每条单链表记录以某个顶点为终点的边



### 邻接多重表（adjacency multilist）

#### 无向图

在无向图中，如果边数为 $m$，则在邻接表表示需要 $2m$ 个单位来存储，用邻接多重表只需要 $m$ 个单位来存储。

首先有一个顶点表，然后有 $m$ 个对象来存储 $m$ 个边，这 $m$ 个对象里存储的是每条边的两个顶点在顶点表中的下标，然后有两个指针：

1. 第一个指针指向的是该对象中第一个顶点的 next neighbor
2. 第二个指针指向的是该对象中第二个顶点的 next neighbor



#### 有向图

对有向图来说，需要用邻接表和逆邻接表来表示，把这两个表结合起来就是死有向图的邻接多重表。

顶点表有两个指针，一个指向第一条入边，一个指向第一条出边。然后 $m$ 个对象存储有向图中的 $m$ 条边，两个顶点分别代表起点和终点



## 图的遍历与连通性

图的遍历：

1. 深度优先遍历（Depth First Search, DFS）
2. 广度优先遍历（Breadth First Search, BFS）



### 深度优先遍历

从起点开始，沿一条路径走到底，再回溯到前一次刚被访问过的拥有未被访问的邻接点w，再从w出发深度遍历，然后如此递归即可。

#### 递归算法实现

辅助数组`visited[]`记录顶点是否被访问过

```c++
template<NameType, DistType> void Graph<NameType, DistType>:: DFS() {
    int* visited = new int[NumVertices];
    for (int i = 0; i < NumVertices; i++) {
        vistied[i] = 0;
    }
    // 从顶点0开始深度优先搜索
    DFS(0, visited);
    delete[] visited;
}

template<NameType, DistType> void Graph<NameType, DistType>:: DFS(int v, visited[]) {
    cout << getValue(v) << " ";
    visited[v] = 1;
    int w = getFirstNeighbor(v);
    
    while (w != -1) {
        if (!visited[w]) {
            DFS(w, visited);
        }
        w = getNextNeighbor(v, w);
    }
}
```

> 邻接表表示 $O(n + e)$
>
> 邻接矩阵表示 $O(n^2)$



### 广度优先遍历

从起点开始（假设为 $v_0$），先依次访问 $v_0$ 的各个未曾访问过的邻接点，然后从这些点出发遍历下一层，直到所有顶点都被遍历过。算法同样需要一个辅助数组`visited[]`表示顶点是否被访问过，还需要一个队列记录正在访问的这一层和上一层的顶点。

#### 代码实现

```c++
template<NameType, DistType> void Graph<NameType, DistType>:: BFS(int v) {
    int* visited = new int[NumberVertices];
    for (int i = 0; i < NumVertices; i++) {
        visited[i] = 0;
    }
    
    cout << getValue(v)<< " ";
    visited[v] = 1;
    queue<int> q;
    q.EnQueue(v);
    
    while (!q.IsEmpty()) {
        v = q.DeQueue();
        int w = getFirstNeighbor(v);
        while (w != -1) {
            if (!visited[w]) {
                cout << getValue(w) << " ";
                visited[w] = 1;
                q.Enqueue(w);
            }
            w = getNextNeighbor(v, w);
        }
    }
    delete[] visited;
}
```

> 邻接表表示 $O(n + e)$
>
> 邻接矩阵表示 $O(n^2)$



### 连通分量

以上讨论的是对一个无向的连通图或一个强连通图的有向图进行遍历，得到一棵深度优先或广度优先生成树。但当无向图(以无向图为例)为非连通图时，从图的某一顶点出发进行遍历(深度，广度)只能访问到该顶点所在的最大连通子图(即连通分量)的所有顶点.



## 最小生成树

### 定义

设G=（V，E）是一个连通的无向图（或是强连通有向图）从图G中的任一顶点出发作遍历图的操作，把遍历走过的边的集合记为TE（G），显然G‘=（V，TE）是G之子图，G‘被称为G的生成树（spanning tree）。

$n$ 个顶点的生成树有 $n-1$ 条边

生成树不唯一，最小生成树指在边上有权重的时候，找到一棵权重之和最小的生成树。

下面介绍两种算法（都采用了**贪心的思想**）：

1. Prim算法
2. Kruskal算法



### Kruskal算法

> 设连通网络 $N = (V, E)$，$V$ 中有 $n$ 个顶点

1. 将所有边都拿掉，即构造出 $n$ 个顶点，$0$ 条边的森林 $F$ = {$T_0, T_1, \dots, T_{n-1}$} 
2. 每次往 $F$ 中放一条边，该边是一端在图中的某棵树 $T_i$ 上而另一端不在 $T_i$ 上的所有边中具有**最小**权值的边（即加入的边不能生成回路）
3. 重复 $n - 1$ 次



实现的时候并不需要将边排序，只需要把边放入**最小堆**即可

用并查集来判断加边时会不会构成回路：

> 若加入边的两个顶点在同一个并查集里，则说明该边会构成回路



### Prim算法

设：原图的顶点集合V(有n 个）生成树的顶点集合U(最后也有n个），一开始为空TE集合为{}

步骤：

1. U={1}任何起始顶点，TE={ }
2. 每次生成（选择）一条边。这条边是所有边(u,v)中代价（权）最小的边
	1. $u \in U $ 
	2. $v \in V-U$ 
	3. $TE=TE+[(u,v)]$ 
	4. $U=U+[v]$
3. 当 $U \ne V$



实现：用两个数组来记录，`nearvex`，`lowcost`

1. `lowcost[]`存放生成树顶点集合内到生成树外各顶点的边上的当前最小权值
2. `nearvex[]`记录生成树顶点集合外各顶点，距离生成树的哪个顶点最近的顶点下标（-1表示已经在生成树集合内）



## 最短路径

> 即路径长度最短（权重之和）

算法：

1. 起点固定且权重没有负值的情况（Dijkstra算法）
2. 权重为任意值的情况
3. 起点不固定且权重任意值的情况



### Dijkstra算法（贪心思想）

不可能从一条比较长的路径而产生一条短的路径。

对我们想要找的某个点到其他所有点的路径，我们进行一个排序，然后每次选择最小的值作为目标点到当前点的路径，然后更新目标点到其他店的路径（类似Prim算法）

$O(n^2)$

### Bellman-Ford算法

边上权重为任意值的时候，我们采用的是贝尔曼-福特算法（此时Dijkstra算法有可能通过一条较长的边但走出一条更短的路径出来）。动态规划，建立多个数组，第$i$个数组表示用$i$步可以到达某个点的最短距离，然后每次增加一步就拿当前步数的最小值和新增一步可以获得的最小值取min即可。

$O(n^3)$

### Floyed算法

1. 有向图的每个顶点作为原点，重复执行Dijkstra算法n次

2. Floyed算法，仍然是$O(n^3)$

算法步骤：$A^i$代表此时可以经过第 $i$ 个点，然后可以通过邻接矩阵计算第 $(i, j) + (j, i)$的值与原先的值取最小



## 活动网络



### AOV网络

#### 拓扑排序

思路：

1. 从图中选择一个入度为0的节点输出（有多个可以随便选择一个）
2. 删除此节点和所有出边
3. 重复执行以上步骤，直到：所有节点都输出了 / 图中有节点但入度不为0（有环）



### AOE网络

关键路径上的事件的最早发生时间和最晚发生时间相同

求各事件允许的最早发生时间和最晚发生时间：

先从源点到汇点求出各事件允许的最早发生时间，公式如下：
$$
Ve_i = \min(Ve_j + dur<j, i>)
$$
代表 $j$ 到 $i$ 的路径，$i$ 的可能最早发生时间， $i$ 比 $j$ 离源点远 

求允许最晚发生时间应该要反过来求，即从汇点到源点求，公式如下：
$$
Vl_i = min(Vl_j - dur<j ,i>)
$$
代表 $j$ 到 $i$ 的路径，$i$ 的允许最晚发生时间， $i$ 比 $j$ 离汇点远 

算法时间复杂度 $O(n + e)$
