# 指令系统

* <span style='color: orange'>**指令集**</span>：CPU能执行的各种不同指令的集合
* 程序由存储在内存中的一组指令组成
* 计算机的基本功能是执行程序
* CPU通过执行指定的指令来完成实际工作

## 指令的要素

* 操作码：指定将要完成的操作
* 源操作数引用：操作会涉及一个或多个源操作数，这是操作所需的输入
* 结果操作数引用：操作可能会产生一个结果
* 下一指令引用：告诉处理器这条指令处理完去哪里去取下一条指令



## 指令表示

在计算机内部，指令由一个位串（01串）来表示

**指令格式**：对应于指令的各要素，这个位串划分成几个字段

* 大多数指令集使用不止一种指令格式

机器指令符号表示法

* 操作码被缩写成助记符来表示

	> ADD：加，SUB：减，MUL：乘，DIV：除，LOAD：从存储器装入，STOR：保存到存储器

* 操作数也可以用符号表示

	> 用寄存器编号或内存地址替换操作数



## 操作码

不同计算机上操作码的数目变动是很大的

所有计算机上都会存在相同的常用操作类型

1. 数据传输
2. 算术运算
3. 逻辑运算
4. 转换
5. 输入/输出
6. 系统控制
7. 控制转移



#### 控制转移

> 问题：存取函数跳转之后的返回的地址
>
> 涉及由目前位置转移到过程的调用指令和由过程返回到调用发生位置的返回指令

1. 方法一：用寄存器：只能用于没有嵌套的函数调用

	> $$
	> RN(register) \longleftarrow PC + \Delta \\
	> PC \longleftarrow X(\text{函数调用的首地址})
	> $$

2. 方法二：返回地址存于过程开始处（可以解决嵌套调用的问题，但递归时会修改掉返回地址，出现错误

	> $$
	> X \longleftarrow PC + \Delta \\
	> PC \longleftarrow X + 1
	> $$

3. 方法三：使用栈：每次调用函数就将返回地址压入栈中



## 操作数

常见类型：地址、数值、字符、逻辑数据

### 地址

一个指令需要有4个地址引用：2个源操作数，1个目的操作数，以及下一指令地址

> 下一指令地址是隐含的

地址数量

* 每条指令中的地址数目越少

	> 1. 指令的长度越短，不需要复杂的CPU
	> 2. 使程序总的指令条数更多，导致执行时间更长，程序也更长更复杂

* 对于多地址指令，普遍具有多个通用寄存器可用，允许某些运算只使用寄存器即可完成，从而使执行加快。

### 数值

### 字符

ASCII：每个字符被表示成唯一的7位二进制串

UNICODE：16/32位

### 逻辑数据

### 大端序和小端序

大端：高位数据存在低地址

小端：高位数据存在高地址

> 对一个字节（同一个地址里的数据），都是高位在前低位在后



## 指令格式的设计原则

* 指令尽量短
	* 指令占用存储空间小
* 有足够的操作码位数
	* 要为操作类型不断增加预留
* 操作码的编码必须有唯一的解释
	* 操作码译码时要么是唯一的合法编码，要么是不合法的
* 指令长度是字节的整数倍
	* 与内存按照字节寻址相对应，便于指令的读取和地址计算
* 合理选择地址字段的个数
	* 涉及到指令长度和规整性，是空间和时间开销权衡的结果
* 指令尽量规整
	* 简化硬件实现

### 指令长度

> 强有力的指令清单和节省空间之间进行权衡考虑

指令长度应该是字符长度或定点数长度的**整数倍**

指令长度应该等于存储器的传送长度（即数据总线宽度），或者这两者的其中之一是另一个的整数倍

### 位的分配

> 操作码数目和寻址能力之间存在着权衡考虑

变长的**操作码**（指令长度固定

* 使用一个最小操作码长度，但是对于某些操作码，可通过使用指令附加位的方法来指定附加的操作

使用寻址位的考虑因素

* 寻址方式的种数
* 操作数的数量
* 寄存器与存储器比较：能用于操作数引用的寄存器越多，指令需要的位数越少
* 寄存器组的数目：对于固定数目的寄存器，功能上的分开将使指令只需较少的位数
* 地址范围
* 寻址粒度：使用较大的字时，需要的地址位更少

#### 变长指令

提供不同长度的各种指令格式

优点：

1. 易于提供大的操作码清单，而操作码具有不同的长度
2. 寻址方式能更灵活，指令格式能将各种寄存器和存储器引用加上寻址方式予以组合

缺点：

1. 增加CPU复杂程度

取至少等于最长指令长度的几个字节或几个字



### 指令集设计