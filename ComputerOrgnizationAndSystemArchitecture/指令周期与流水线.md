# 指令周期与流水线

## 指令周期

### 指令周期

指令周期：处理单个指令的过程

* 取指周期：从内存中提取一条指令
* 执行周期：执行所提取的指令

只有当机器关闭，发生某种不可恢复的错误或遇到停止计算机的程序指令时，程序执行才会停止



### 带中断的指令周期

中断禁止 和 中断允许



### 间址周期

指令的执行可能涉及一个或多个存储器中的操作数，它们每个都要求一次存储器访问

使用间接寻址，还需要额外的存储器访问

<span style='color: orange'>间址周期</span>：把间接地址的读取堪称是一个额外的指令子周期



## CPU的任务

1. 取指令：CPU必须从存储器（寄存器、Cache、主存）读取指令
2. 解释指令：必须对指令进行译码，已确定所要求的动作
3. 取数据：指令的执行可能要求从存储器或输入/输出（I/O）模块中读取数据
4. 处理数据：指令的执行可能要求对数据完成某些算数或逻辑运算
5. 写数据：执行的结果可能要求写数据到存储器或I/O模块



### CPU需求：寄存器

* CPU需要在指令周期中临时保存指令和数据
* CPU需要记录当前所执行指令的位置，以便知道从何处得到下一条指令

MBR：存储缓冲寄存器

MAR：存储地址寄存器

IR：指令寄存器

PC：程序计数器

> 取完指令之后PC就会加一，而不是等到指令执行完毕



## 指令流水线

流水处理（pipelining）

> 如果一个产品要经过几个制作步骤，通过把制作过程安排在一条装配线上，多个产品能在各个阶段同时被加工

<span style='color: red'>**指令流水线**</span>：一条指令的处理过程分成若干个阶段，每个阶段由相应的功能部件完成



### 两阶段方法

将指令处理分成两个阶段：取指令和执行指令

在当前指令的执行周期期间取下一条指令

问题：

1. 执行时间一般要长于取指时间
2. 主存访问冲突
3. 条件分支指令使得待取的下一条指令的地址是未知的



### 六阶段方法

为了进一步的加速，流水线必须有更多的阶段

1. 取指令（Fetch instruction, FI）：读下一条预期的指令到缓冲器
2. 译码指令（Decode instruction, DI）：确定操作码和操作数指定符
2. 计算操作数（Calculate operands, CO）：计算每个源操作数的有效地址
2. 取操作数（Fetch operands, FO）：从存储器取出每个操作数，寄存器中的操作数**不需要取**
2. 执行指令（Execute instruction, EI）：完成指定的操作。若有指定的目的操作数位置，则将结果写入此位置
2. 写操作数（Write operand, WO）：将结果存入存储器

各个阶段所需要的时间几乎是相等的（**但并没有完全相等**）。



不是所有指令都包含6个阶段

* 例：一条LOAD指令不需要WO阶段
* 为了简化流水线硬件设计，在假定每条指令都要求这6个阶段的基础上来建立时序

不是所有阶段都能并行完成

* 例：FI/FO/WO都设计存储器访问

若6个阶段不全是相等的时间，则会在各个流水线阶段涉及某种等待

限制：

1. 条件转移指令能使若干指令的读取变为无效
2. 中断 -- 流水线失效



### 流水线性能

假设

* $t_i$：流水线第 $i$ 段的电路延迟时间
* $t_m$：最大段延迟（通过耗时最长段的延迟）
* $k$：指令流水线段数
* $d$：锁存延时（数据和信号从上一段送到下一段所需的段间锁存接收时间）

<span style='color: red'>**周期时间**</span>
$$
t = \max[t_i] + d = t_m + d
$$
令 $T_{k, n}$ 为 $k$ 阶段流水线执行所有 $n$ 条指令所需的总时间，那么：
$$
T_{k,n} = [k+(n-1)]t
$$
**加速比**：
$$
S_k = \frac{T_{1,n}}{T_{k,n}} = \frac{nkt}{[k+(n-1)]t} = \frac{nk}{k + (n-1)} = \frac{n}{1 + \frac{n-1}{k}}
$$

## 流水线冒险

在某些情况下，指令流水线会阻塞或停顿（stall），导致后续指令无法正确执行。

类型

1. 结构冒险（Structure hazard）/ 硬件资源冲突

	> 也叫资源冒险（resource hazard）

2. 数据冒险（Data hazard）/ 数据依赖性

3. 控制冒险（Control hazard）



### 结构冒险

原因：已进入流水线的不同指令在同一时刻访问相同的硬件资源

解决：使用多个不同的硬件资源，或者分时使用同一个硬件资源（分时复用，上升沿和下降沿交给不同的指令）

> Cache的引入和数据Cache与代码Cache



### 数据冒险

原因：未生成指令所需要的数据

解决方案：

1. 插入`nop`指令，即什么都不做的指令，让需要前面数据的指令延时进行

	> 坏处：时间的浪费

2. 插入bubble（硬件控制）

	> 坏处：时间的浪费

3. 转发（forwarding）/ 旁路（bypassing）

	> 将`ALU`得到的结果就直接用于接下来的指令。（只能用于后面所用的数据时前面用`ALU`计算而出的
	>
	> 不足：无法解决`LOAD`指令所带来的问题

4. 交换指令顺序



### 控制冒险

原因：指令的执行顺序被更改

1. 转移（Transfer）：分支（branch），循环（loop），...
2. 中断（Interrupt）
3. 异常（Exception）
4. 调用 / 返回（Call / Return）

解决：取多条指令

* 多个指令流：复制流水线的开始部分，并允许流水线同时取这两条指令，使用两个指令流
* 预取分支目标：识别出一个条件分支指令时，除了取此分支指令之后的指令外，分支目标处的指令也被取来
* 循环缓冲器：由流水线指令取指阶段维护的一个小的但极高速的存储器，含有 n 条最近顺序取来的指令

> 问题：多次分支会导致流水线数目不断增长膨胀，无法控制

解决：分支预测

* 静态预测
	* 预测绝不发生
	* 预测总是发生
	* 依操作码预测
* 动态预测
	* 发生 / 不发生切换
	* 转移历史表
