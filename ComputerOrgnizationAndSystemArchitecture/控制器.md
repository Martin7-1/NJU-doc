# 控制器

## 寄存器分类

1. 用户可见寄存器

> user-visible register

允许编程人员通过机器语言或汇编语言访问，通过优化寄存器的使用而**减少对主存的访问**

2. 控制和状态寄存器

> control and status register

* 由控制器来控制CPU的操作，并由拥有特权的操作系统程序来控制程序的执行

* 大多数控制和状态寄存器在大多数机器上是用户不可见的

	> 某些在控制或操作系统模式下执行的机器指令是用户可见的



**Tips:** 两者的区分并不严格



### 用户可见寄存器

1. 通用寄存器 (general-purpose register)

	> 可被程序员指派各种用途

2. 数据寄存器 (data register)

	> 仅可用于保存数据而不能用于操作数地址的计算

3. 地址寄存器 (address register)

	> 可以使自身有某种通用性，或是专用于某种具体的寻址方式
	>
	> 例如：段指针，变址寄存器，栈指针

4. 条件码寄存器 (condition codes register) / 标志 (flag) 寄存器

	> CPU硬件设置这些条件位作为操作的结果
	>
	> 至少是部分用户可见的
	>
	> **并非所有机器都有**

#### 设计出发点

使用完全通用的寄存器还是规定各寄存器的用途

**寄存器数量**

1. 太少的寄存器会导致更多的存储器访问
2. 太多的寄存器又不能显著地减少存储器访问

**寄存器长度**

1. 应该要能保存大多数数据类型的值
2. 某些机器允许两个相邻的寄存器作为一个寄存器来保持两倍长度的值



#### 保存和恢复

子程序调用会导致自动保存所有用户可见的寄存器，并在返回时自动取回

* 这些保存和恢复是作为调用和返回指令执行功能的一部分，由CPU完成
* 这允许各个子程序独立地使用用户可见寄存器

子程序调用之外保存用户



### 控制和状态寄存器

1. 程序计数器（Program counter, PC）
	* 存有待取指令的地址
	* 通常在每次取指令之后，PC的内容即被CPU更改，转移或跳步指令也会修改PC的内容，因此总指向被执行的下一条指令
2. 指令寄存器（Instruction register, IR）
	* 存有最近取来的指令，在其中分析操作码和操作数
3. 存储器地址寄存器（Memory address register, MAR）
	* 直接与地址总线相连，存有存储器位置的地址
4. 存储器缓冲寄存器（Memory buffer register, MBR）
	* 直接与数据总线相连，存有将被写入存储器的数据字或从存储器读出的字，用户可见寄存器再与MBR交换数据
5. 程序状态字（Program status word, PSW）
  * 一个或一组包含状态信息的寄存器，包含条件码加上其他状态信息
  * 包含的字段或标志
  	* 符号
  	* 零
  	* 进位
  	* 等于
  	* 溢出
  	* 中断允许 / 禁止
  	* 监管
6. 指针寄存器：指向附加状态信息的存储器块
7. 中断向量寄存器：
8. 系统栈指针：
9. 页表指针寄存器：



#### 设计出发点

**对操作系统的支持**

* 某些类型的控制信息是专门为操作系统使用的
* 若CPU设计者对将要使用的操作系统有基本的了解，则寄存器的组织可能在一定程度上为该操作系统定制

**控制信息在寄存器和存储器之间的分配**

* 一个普遍的做法是将存储器最前面（最低地址）的几百或几千个字用于控制母的
* 在成本和速度之间权衡





## 微操作

执行程序时，计算机操作是由一系列指令周期组成，每个周期执行一条机器指令

每个指令周期又可以看作是由几个更小的子周期组成

> 包括：取指，间址，执行，中断

每个子周期由一系列<span style='color: orange'>**涉及CPU寄存器操作**</span>的更小步骤组成，这些步骤称为<span style='color: red'>**微操作**</span>



### 取指周期

出现在每个指令周期的开始，将指令从存储器中取出

> 这里会访问一次主存



### 间址周期

指令执行前会有一个间址周期，来读取有效地址（注意这里并没有读取操作数）

完成间址周期后，IR的状态与不使用间接寻址方式的状态是相同的，已经为执行周期准备就绪



### 中断周期

在完成执行周期的时候，确定是否有允许的中断发生，如果有，则出现一个中断周期



### 微操作分组的原则

1. 事件的流动顺序必须是恰当的

	> 例：MAR <- (PC) 必须先于 MBR <- 主存，因为主存读操作需要用到MAR中的地址

2. 必须避免冲突

	> MBR <- 内存 和 IR <- MBR 这两个微操作不应该出现在同一时间里

3. 满足上述条件的情况下，所用的单位时间尽可能少



### 指令周期代码（Instruction Cycle Code, ICC）

* 取指、间址、中断周期各有一个微操作序列，执行周期则对于每个操作码有一个微操作序列

* 指令周期代码：假设一个2位的ICC寄存器，明确CPU处于指令周期的哪个阶段

	> 00：取指，01：间址，10：执行，11：中断

	![image-20211219194052302](C:/Users/Zyi/AppData/Roaming/Typora/typora-user-images/image-20211219194052302.png)



### CPU内部总线

1. ALU和寄存器都连接到CPU内部总线上
2. 为了数据在该内部总线和各寄存器之间传递，内部总线和寄存器之间有门和控制信号
3. 控制线控制着数据和系统总线（外部）的交换以及ALU的操作

> 一时间在CPU内部总线上只能够有一个数据，否则多个数据会混淆起来



## 控制器

### 控制CPU的功能需求

CPU的基本元素：ALU，寄存器组，内部数据通路，控制器，外部数据通路

CPU需要完成的微操作：

1. 再寄存器之间传送数据
2. 将数据由寄存器传送到外部接口（如系统总线）
3. 将数据由外部接口传送到寄存器
4. 将寄存器作为输入和输出，完成算术和逻辑运算

控制器的两个基本任务：

1. 定序：根据正被执行的程序，控制器使CPU以正确的顺序通过一系列微操作
2. 执行：控制器使每个微操作得以完成



### 控制器的输入

**指令寄存器**：当前指令的寻址方式和操作码

**标志**：确定CPU的状态和前一个ALU操作的结果

**时钟**：控制器要在每个时钟脉冲完成一个或一组同时的微操作

**来自控制总线的控制信号**：向控制器提供控制信号

> 例：中断请求



### 控制器的输出

**CPU内的控制信号**

* 用于寄存器之间传送数据
* 用于启动特定的ALU功能

**到控制总线的控制信号**

* 到存储器的控制信号
* 到I/O模块的控制信号

> 所有的控制信号最终作为二进制输入量直接输入到各个逻辑门上
>
> 即到逻辑门上的信号要么是 $0$ 要么是 $1$



#### 控制信号示例：取指周期



### 控制器的最小特性

控制器只需要知道将被执行的指令和算术、逻辑运算结果的性质（如正负、溢出等），而不需要知道正被处理的数据获得到的实际结果具体是什么

控制器只是以少量的送到CPU内的和送到系统总线上的控制信号来实现控制



### 控制器的实现

* 硬布线实现（hardwired implementation）
	* 控制器是一个组合电路，把输入逻辑信号转换为一组输出逻辑信号，即控制信号
* 微程序实现（microprogammed implementation）
	* 控制逻辑是微程序指定的，控制器通过执行微程序里的每一条微指令来实现控制



#### 硬布线实现：控制器输入

标志和控制总线信号：每位都有特定的意义

指令寄存器：

1. 通过译码，使每一操作码有一个唯一的逻辑输入

2. 译码器有 $n$ 个输入和 $2^n$ 个输出

	> 控制器要考虑变长的操作码，译码器会更复杂一些

**时钟**：

1. 在一个指令周期内控制周期要在不同时间单位发送不同的控制信号
2. 使用一个定时器作为控制器的输入，并且控制器在指令周期结束时必须通知定时器以使其重新开始计数（子周期内递增，子周期结束就应该清零）



#### 硬布线实现：控制器逻辑

1. 为每个输出的控制信号设计一个关于控制器输入的布尔表达式

2. 定义两个新的控制信号 $P$ 和 $Q$

	> $PQ = 00$：取指周期，$PQ = 01$：间址周期， $PQ = 10$：执行周期，$PQ = 11$：中断周期

	![image-20211219195612170](C:/Users/Zyi/AppData/Roaming/Typora/typora-user-images/image-20211219195612170.png) 

（注：乘是与，加是或）

（LDA：LOAD指令，ADD：ADD指令，AND：AND指令）



#### 微程序实现：基本概念和思路

微程序（固件）介于硬件和软件之间

* 设计固件比设计硬件容易，但写固件程序比软件程序困难
* 微指令序列

**微指令**：每行描述一个时间内出现的一组微操作

**基本思路**：

1. 对于每个微操作，控制器的任务是产生一组控制信号，即控制器发出的每根控制线或开或关（每根控制线由一个二进制数字表示）
2. 构造一个控制字，每位代表一根控制线，这样每个微操作能用控制字中的不同的 $0$ 和 $1$ 的样式来表示
3. 将这些控制字在一起，可以表示控制器需要完成的微操作序列



* 由于微操作序列不是固定的，把控制字放入一个存储器单元中，每个字有自己唯一的地址

	* 添加少数几位用于指示条件的真假

		> 若条件位指示的条件为假，则顺序执行下一条指令
		>
		> 若条件位指示的条件为真，则地址字段指向的微指令是将被执行的下一条微指令

	* 给每个控制字添加一个地址字段，以指示某种条件为真时，将要执行的下一控制字的位置



#### 微程序控制器：任务

**微指令定序**（microinstruction sequencing）

* 根据当前的微指令、条件标志和指令寄存器的内容，产生下一微指令的控制存储器的地址
* 设计考虑
	* 微指令的大小：减小微指令的大小就能节省控制存储器的成本
	* 地址生成空间：尽可能地执行微指令

**微指令执行**（microinstruction execution）

* 产生控制信号：发往CPU内部，送往外部控制总线或其他外部接口



#### 微程序控制器：构成

1. 定序逻辑：向控制地址寄存器装入地址，并发出读命令
2. 控制地址寄存器：含有下面即将被读取的微指令地址
3. 控制存储器：存有一组微指令
4. 控制缓冲寄存器：存放被读出的微指令
