# 虚拟内存

## 操作系统

操作系统：一种控制应用程序运行和在计算机用户与计算机硬件之间提供接口的程序

目标：

* 使计算机使用起来更方便
* 允许计算机系统的资源以有效的方式使用



## 存储器管理

早期计算机的主存中仅包含**系统软件**和一个用户程序。 -- 单道程序设计

现在计算机的主存中包含**操作系统**和若干个用户程序

* 当所有任务都需要等待I/O时，为了避免处理器处于空闲状态，需要尽可能让更多的任务进入主存
* 多道程序设计：让处理器一次处理多个任务，提高处理器的利用率

存储器管理

* 在多道程序系统中，主存需要进一步划分给多个任务，划分的任务由操作系统动态执行
* 这里不考虑“**进程**”这一概念。



## 如何将更多任务装入主存

1. 增大主存容量
2. 使用交换（exchange）技术
	* 当主存中没有处于就绪的任务时，操作系统调入其他任务来执行
	* 分区（partitioning）与分页（paging）
3. 虚拟存储器
	* 请求分页：每次访问仅将当前需要的页面调入主存，而其他不活跃的页面放在外存磁盘上
	* 虚拟地址

### 分区方式

* 分区方式：将主存分为两大地址
	* 系统区：固定的地址范围内，存放操作系统
	* 用户区：存放所有用户程序



#### 简单固定分区

* 用户区划分成**长度不等**的**固定长**分区
* 当一个任务调入主存时，分配一个可用的，能容纳它的、最小的分区（一个区**只能**放一个任务，不能够将两个小任务放在同一个分区中）
* 优点：简单
* 缺点：浪费主存空间



#### 可变长分区

* 用户区按每个任务所需要的内存大小进行分配

* 优点：提高了主存的利用率

* 缺点：时间越长，存储器中的**碎片**就会越多

	> 做完大任务后的内存区域存入了一个小任务，就会留下一个较小的碎片的内存空间。（分散的，没有办法被联合起来使用的）



### 分页方式

基本思想：

* 把主存分成**固定长**并且比较小的存储块，称为<span style = 'color: red'>**页框（page frame）**</span>，每个任务也被划分成固定长的程序块，称为<span style = 'color: red'>**页（page）**</span>

* 将页装入页框中，且**无需采用连续的页框**来存放一个任务中所有的页

> 逻辑地址：指令中的地址
>
> 物理地址：实际主存地址
>
> 页表：能够通过页表知道任务在主存中的物理地址



## 虚拟存储器

问题：内存的大小是有限的，但对内存的需求不断增加

### 基本思想

* <span style = 'color: red'>**请求分页**</span>：仅将当前需要的页面调入主存
	* 通过硬件将**逻辑地址**转换为**物理地址**
	* 未命中时在主存和硬盘之间交换信息

### 优点

* 在不扩大物理内存的前提下，可以载入更多的任务
* 编写程序时不需要考虑可用物理内存的状态
	* 程序员认为可以独享一个连续的、很大的内存
* 可以在大于物理内存的逻辑地址空间中编程

### 设计的一些问题

1. 页大小
2. 映射算法：全相连映射
3. 写策略：写回
4. 类型
	1. 分页式虚拟存储器
	2. 分段式虚拟存储器
	3. 段页式虚拟存储器

> Cache和主存的速度差距比主存和硬盘的速度差距小很多，所以我们应该尽可能减少对硬盘的访问，提高对主存的利用率。



### 分页式虚拟存储器

主存储器和虚拟地址空间都被划分为大小相等的页面

* 虚拟页（virtual page, VP）/逻辑页（logical page）：虚拟地址空间中的页面
* 物理页（physical page, PP）/页框（page frame）：主存空间中的页面

#### 页表

* 页表中包含了所有<span style = 'color: red'>**所有虚拟页**</span>的信息，包括虚拟页的存放位置、装入位（valid）、修改位（dirty）、存取权限位等
* 保存在主存中
* 编写程序时认为有一块很大、连续的存储空间，写的是虚拟地址
* 虚拟地址：虚拟页号 + 页内偏移量



**页表的存放位置**

1. null：还未存放任何东西，没有指针指向实际的主存物理地址
2. PPx（x为数字）：指向主存中的一块
3. 空：指向磁盘的一块

> 存放地址中存储的是一样长的数据，以指向内存中的页的物理地址的长度为准，不需要存放虚拟页号（因为页表中存储的是所有的虚拟页，不会再有多的虚拟页了）

<span style='color :red'>虚拟页号</span> + <span style = 'color: blue'>页内偏移量</span> -> <span style='color: green'>物理页号</span> + <span style = 'color: blue'>页内偏移量</span>

> 页内偏移量相同，因为虚拟页和物理页的大小是一样的



#### 快表

> Translation Lookaside Buffer, TLB

页表的使用增加了主存的访问次数

为了减少访问主存的次数，把页表中**最活跃**的几个页表项复制到Cache中

后备转换缓冲器（简称“快表”）：将页表项放入Cache中

* 映射：关联映射，组关联映射
* 替换：随机替换

主存中的页表相应地称之为“慢表”



### 分段式虚拟存储器

将程序和数据分成不同长度的段，将所需的段加载到主存中。

虚拟地址：段号 + 段内偏移量

与分页式虚拟存储器相比：

* 分页式虚拟存储器：
	* 优点：实现简单、开销少
	* 缺点：一个数据或一条指令可能会横跨两个页面
* 分段式虚拟存储器
	* 段的分界与程序的自然分界相对应，易于编译
	* 会产生碎片，长度不固定



### 段页式虚拟存储器

将程序和数据分段，段内再进行分页

* 每个分段都有一个页表

虚拟地址：段号 + 页号 + 页内偏移量

优点：程序按段实现共享与保护

缺点：需要多次查表