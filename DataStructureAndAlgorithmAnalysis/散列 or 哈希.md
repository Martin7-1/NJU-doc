# 散列/哈希

## 散列函数（Hash Function）

如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的。这个特性是散列函数具有[确定性](https://zh.wikipedia.org/wiki/确定性)的结果，具有这种性质的散列函数称为单向散列函数。但另一方面，散列函数的输入和输出不是唯一对应关系的，如果两个散列值相同，两个输入值很可能是相同的，但也可能不同，这种情况称为“[散列碰撞](https://zh.wikipedia.org/w/index.php?title=雜湊碰撞&action=edit&redlink=1)（collision）”



## 散列表（Hash Table）

用数组，某个数值通过**散列函数**计算出的值作为其在数组中的下标。

> 散列函数应该尽可能让不同的输入有不同的输出

时间复杂度基本为 $O(1)$



## problem

1. 需要找到合适的哈希函数

2. 如何解决“散列碰撞”问题

3. 选择适合的加载因子（load factor）$\alpha$

	> $$
	> \alpha = \frac{n}{b}
	> $$
	>
	> 1. $n$ 是散列表中的元素个数
	> 2. $b$ 是散列表的容量（buckets）
	> 3. $\alpha > 1$：碰撞频率大
	> 4. $\alpha < 1$：碰撞频率小



## 散列函数

1. 取余法
2. 平方取中法
3. 乘法杂凑函数

对非数字的变量，也可以构建散列函数



## 冲突处理

碰撞的两个（或多个）关键码称为同义词，即 $H(k_1) = H(k_2), k_1 \ne k_2$

1. 开放地址的线性探测法

	> 如果某个要放的位置已经有元素了，那么就检测**旁边的格子**（索往索引变大的方向），然后放到旁边的格子
	>
	> 查找相同，但查找可能不能 $O(1)$ 复杂度
	>
	> clustering problem：数据堆积，线性探测法容易遇到的问题
	>
	> 注意线性探测法删数据的时候会出现无法查找到数据的问题（可以用一个标记来标记删除）

2. 二次探测法（Quadratic probing）

	> 如果某个要放的位置已经有元素了，那么就按二次函数的递增来检测格子（$d + 1, d + 2^2, d + 3^2...$）

3. 双散列（Double Hashing）-- 解决堆积问题

	> 如果某个要放的位置已经有元素了，那么就用**新的散列函数**再计算一次值，然后放到$d + c, d+2c,...$的位置（$c$：新的散列函数计算出的value）

4. 分离链接法（Separate Chaining）

	> 发生冲突时加一个单链表



## Rehash（再散列）

> 解决扩容问题，大于加载因子（load factor）时对散列表进行扩容。