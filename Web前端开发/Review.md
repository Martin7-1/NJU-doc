# Review

## Introduction

1. 前端技术栈
2. 前端学习路线，课程仅包括基础部分
3. 浏览器技术，布局引擎 、JS引擎
4. DNS，URL/URI/URN
5. Web发展历程，Web3.0

### 前端技术栈

1. 硬技能
   1. 应用技能
      1. JavaScript：编程能力、架构能力、抽象能力
      2. CSS：综合应用能力、必要的hack方案
      3. HTML：标签的合理使用、web API
   2. 核心技能
   3. 计算机理论知识：数据结构、算法、软件工程
2. 软技能
   1. 用户体验：性能优化策略、浏览器渲染原理、JavaScript引擎工作原理
3. 扩展技能
   1. Node.js：web 应用的工作原理、HTTP 协议

### 浏览器技术、布局引擎、JS 引擎

浏览器：四大派系，核心是「布局引擎」，用以决定文档和样式如何渲染

1. 微软的 Trident，IE 的内核
2. 基于开源项目 WebKit 的浏览器
3. 基于 Blink 开源项目的浏览器
   1. 2013 年从 Webkit 中派生，是最新版的 Chrome 和 Opera 的布局引擎
4. Mozilla 公司的 Gecko，Firefox 的内核

JavaScript 引擎：

1. Chakra，IE
2. SquirrelFish Extreme / Nitro，Webkit
3. V8，Chrome 和 Opera（第一个在执行前将 JS 编译为原生代码的 JS 引擎）
4. SpiderMonkey，Firefox

### DNS

1. DNS 是域名系统，Domain Name System 的缩写
2. 因特网上作为域名和 IP 地址互相映射的一个分布式数据库
3. DNS 的作用：
   1. 正向解析：根据主机名称（域名）查找对应的 IP 地址
   2. 反向解析：根据 IP 地址查找对应的主机域名

#### 解析器与名称服务器

1. 主机上的引用程序通过 DNS 客户端访问域名系统，称为解析器
2. 解析器联系 DNS 服务器，成为名称服务器
3. DNS 服务器返回 IP 地址给解析器，解析器将 IP 传递给应用程序
4. 反向查找也可以，即查找给定 IP 地址的主机名

![解析器与名称服务器](https://img-bed-1309306776.cos.ap-shanghai.myqcloud.com/img/20230220130428.png)

#### DNS 名称层次结构

1. DNS 层次结构可以用树来比喻
2. 根域名和顶级域名由互联网中央名称注册机构（ICANN）管理
3. 在顶级域名（TLD, Top-Level Domain）之下，名称空间的管理被委派给不同的组织
4. 每个组织都可以进一步授权

#### 域名

1. 主机和DNS域名根据其在域名树中的位置命名
2. DNS域名树中的每个节点都可以通过唯一的全限定域名（FQDN）来标识。FQDN给出了在DNS树中的位置。
3. 一个FQDN由标签组成，标签之间用点（“.”）隔开。
   1. 结尾可以有一个句号。
   2. 每个标签最多可以有63个字符
   3. FQDN包含字符、数字和破折号(" - ")
   4. FQDN不区分大小写

#### 名称服务器的层次结构

1. 层次名称空间的解析是由层次化的名称服务器完成的
2. 每个服务器负责（授权）DNS 名称空间的一个连续部分，称为区域
3. 区域是子树的一部分
4. DNS 服务器对其所属区域内的主机进行应答

#### 域名解析

1. 用户程序发出主机名到 IP 地址的请求
2. 本地解析器向主机的名称服务器提出 DNS 查询
3. 名称服务器检查它是否被授权回答查询
   1. 如果是，它会响应
   2. 否则，它会从根树开始查询其他名称服务器
4. 当名称服务器得到答案时，它会将其发送到解析器
5. 递归查询和迭代查询
   1. 递归查询:如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文（即替主机继续查询），而不是让主机自己进行下一步查询。 0
   2. 迭代查询:当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。

### URI/URL/URN

1. URI：Uniform Resource Identifier，统一资源标识符。用于标识某一互联网资源名称的字符串，该种标识允许用户对任何（包括本地和互联网）的资源通过特定的协议进行交互操作。
2. URL：Uniform Resource Locator，统一资源定位符。URL 是一种 URI，它标识一个互联网资源，并指定对其进行操作或获取该资源的方法
3. URN：Uniform Resource Name，统一资源名称，定义某事物的身份，URN 仅用于命名，而不指定地址。

#### URL 编码

1. URL编码将字符转换为可通过因特网传输的格式。
2. URL只能使用ASCII 字符集通过因特网进行发送。
3. 由于URL通常包含 ASCII 集之外的字符，因此必须将URL转换为有效的ASCII格式。
4. URL编码使用后跟十六进制数字的 "%" 替代不安全的 ASCII 字符。
5. URL不能包含空格。URL 编码通常使用加号（+）或 %20 替代空格。

## HTML

1. 基本标签，块内元素与行内元素
2. HTML5，优势、应用
3. 新元素、新功能
4. 语义化

### 基本标签

#### HTML 组成

1. DOCTYPE
2. Head `<title>` 是必须的
3. Body：需要呈现的内容

#### 标签

1. `<title>`：当前网页的标题。
   1. 主要用于：
      1. 定义浏览器工具栏中的标题
      2. 提供页面被添加到收藏夹时的标题
      3. 显示在搜索引擎结果中的页面标题
   2. 标题长度受限
   3. SEO 权重大
2. `<meta>`：用于提供关于 HTML 文档的元数据
   1. 只能出现在 `<head>` 里
   2. 通常用于给出网页描述、关键词、文档作者、最后修改日期等信息。
   3. `<meta http-equiv="Content-Type" content="text/html" charset="iso-8859-1">`
   4. `<meta name="description" content="Authors' web site for Building Java Programs">`
   5. `<meta name="keywords" content="java, textbook">`
3. `<h1>` - `<h6>`：标题标签
   1. 被用来定义 HTML 标题
   2. 用标题来呈现文档结构时很重要的
4. `<p>` 段落
5. `<br>`：插入一个简单的换行符
   1. 空标签，这意味着它没有结束标签，也没有标签内容
6. `<a>`：定义超链接
   1. `<a>` 元素最重要的属性是 href 属性，它指定链接的目标
   2. 使用 CSS 来改变链接的样式
7. `<img>`：图像
   1. 空标签，只包含属性，并且没有闭合标签
   2. src 指 source，原属性的值时图像的 URL 地址
   3. alt 属性用来为图像定义一串预备的可替换的文本
8. `<em>`：呈现为被强调的文本
9. `<strong>`：定义重要的文本
10. 表格相关
    1. `<table>`
    2. `<tr>`：一行
    3. `<td>`：行里的元素（非 header）
    4. `<th>`：行里的元素（header）
    5. `<caption>`
    6. 不要用于布局，结构混乱不清晰，CSS 更强大，访问性更好，能够在范围更广的设备上运作，比如手机。且机器难以理解，不利于 SEO，基于 CSS 的布局页面比表单布局更小更简单
11. `<blockquote>`：块元素
12. `<q>`：行内引用
    1. 为什么不使用「“”」：XHTML 不应该直接包含引号字符，应该写成转义 `&quot;`
    2. 使用 `<q>` 的话可以使用 CSS 样式

#### 表单

表单属性说明如何处理用户输入

1. action="url"（必须）：制定单击 submit 按钮时将数据发送到哪里
2. method="get"（缺省）：将表单数据以名称/值对的形式附加到 URL 中
   1. URL 的长度时有限的（大约 3000 字符）
   2. 绝对不要使用 GET 请求来发送敏感数据（参数在 URL 中是可见的）
   3. 对于用户希望加入书签的表单提交很有用
   4. GET 更适用于非安全数据，比如在 Google 中查询字符串
3. method="post"
   1. 将表单数据附加到 HTTP 请求的 body 内（数据不显示在 URL 中）
   2. 没有长度限制
   3. 通过 POST 提交的表单不能加入书签

`<input>`：规定了用户可以在其中输入数据的输入字段

### 块内元素与行内元素

1. 块级元素占据其父元素（容器）的整个水平空间，垂直空间等于其内容高度，因此创建了一个“块”。
   1. 例如: `<p>`、`<ul>`、`<ol>`、`<table>`
   2. 通常浏览器会在块级元素前后另起一个新行
2. 行内元素只占据它对应标签的边框所包含的空间。
   1. 例如: `<strong>`, `<span>`, `<image>`
   2. 浏览器允许许多行内元素出现在同一行上
   3. 必须嵌套在块级元素中

### HTML5、优势、应用

#### 应用

1. 本地数据存储
2. 访问本地文件
3. 本地 SQL 数据
4. 缓存引用
5. Javascript 工作者
6. XHTMLHttpRequest 2

#### 优势

1. 跨浏览器兼容性
2. 大道至简
3. 语义化
4. 可用性和用户体验的改进
5. 无插件范式
6. 安全
7. 大量用于移动应用和游戏
8. 在网站抓取和索引方面，HTML5 对 SEO 友好

### 新元素、新功能

#### HTML5 Web 存储

1. localStorage：用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除
2. sessionStorage：用于临时保存同一窗口（或标签页）的数据，在关闭窗口或标签页之后将会删除这些数据

#### HTML5 应用程序缓存

1. 使用 HTML5，通过创建 cache manifest 文件，可以轻松地创建 web 应用的离线版本。
2. HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。
3. 应用程序缓存为应用带来三个优势：
   1. 离线浏览 - 用户可在应用离线时使用它们
   2. 速度 - 已缓存资源加载得更快
   3. 减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。
4. manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。manifest 文件可分为三个部分：
   1. CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存
   2. NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存
   3. FALLBACK - 在此标题下列出的文件规定当⻚面无法访问时的回退⻚面（比如 404 ⻚面）

### 语义化

1. 根据结构化的内容选择合适的标签
2. 为何？
   1. 有利于SEO
   2. 开发维护体验好
   3. 用户体验更好
   4. 更好的可访问性，方便任何设备对代码进行解析

## CSS

1. 基本概念
2. 选择器
3. 层叠排序
4. CSS3新特性、CSS Sprites
5. 布局，盒模型，BFC，响应式web设计、移动优先、渐进渐强

### 选择器

1. id 选择器（#）
2. class 选择器（.）
3. 标签选择器
4. 属性选择器（[]）
5. 伪类选择器（:）
6. 伪元素选择器（::）
7. 组合选择器
   1. 后代选择器（空格）：不一定是父元素
   2. 子元素选择器（>）：一定是父元素
   3. 相邻兄弟选择器（+）
   4. 后续兄弟选择器（~）

### 层叠排序

用来解决样式说明冲突的整个排序过程称为层叠

1. 浏览器缺省样式
2. 内联样式
3. 嵌入样式表
4. 外部样式表

优先级从高到低：内联样式、嵌入样式表、外部样式表、缺省样式

相互冲突的声明将按以下顺序应用，后一种声明将覆盖前一种声明：

1. 用户代理样式表中的声明（例如，浏览器的默认样式，在没有设置其他样式时使用）。
2. 用户样式表中的常规声明（由用户设置的自定义样式）。
3. 作者样式表中的常规声明（这些是我们 web 开发人员设置的样式）。
4. 作者样式表中的 !important 声明
5. 用户样式表中的 !important 声明
6. 用户代理样式表中的 !important 声明

优先级计算：百位（ID）+ 十位（类、属性、伪类）+ 个位（元素、伪元素）

### CSS3 Sprites

1. 图像精灵是单个图像中包含的图像集合。
2. 优点：
   1. 包含许多图像的网⻚可能需要很⻓时间才能加载，同时会生成多个服务器请求。
   2. 使用图像精灵将减少服务器请求的数量并节约带宽。
   3. 解决了网⻚设计师在图片命名上的困扰
   4. 更换⻛格方便
3. 缺点：
4. 维护麻烦
5. 图片合并费时费力

### 布局，盒模型，BFC

![盒模型](https://img-bed-1309306776.cos.ap-shanghai.myqcloud.com/img/20230220155308.png)

1. 最终元素的总宽度计算公式：总元素宽度 = 内容宽度 + 左填充 + 右填充 + 左边框 + 右边框 + 左边距 + 右边距
2. 最终元素的总高度计算公式：总元素高度 = 内容高度 + 顶部填充 + 底部填充 + 上边框 + 下边框 + 上边距 + 下边距

#### 默认布局

1. 默认的，一个块级元素的内容宽度是其父元素的 100%，其高度与其内容高度一致。内联元素的 height width 与内容一致。你无法设置内联元素的 height width --- 它们就那样置于块级元素的内容里。如果你想控制内联元素的尺寸，你需要为元素设置display: block; （或者，display: inline-block; inline-block 混合了 inline 和 block 的特性。）
2. 正常布局流是一套在浏览器视口内放置、组织元素的系统。默认的，块级元素按块流向布置，即基于其父元素的书写顺序（默认值： horizontal-tb）。 每个块级元素会在上一个元素下面另起一行，它们会被设置好的 margin 分隔。以英语为例，或者其他的水平书写、自上而下模式里，块级元素被垂直组织的。
3. 内联元素的表现有所不同 --- 它们不会另起一行；只要在其父级块级元素的宽度内有足够的空间，它们与其他内联元素、相邻的文本内容（或者被包裹的）被安排在同一行。如果空间不够，溢出的文本或元素将移到新的一行。
4. 如果两个相邻的元素都设置了 margin 并且两个 margin 有重叠，那么更大的设置会被保留，小的则会消失 --- 这被称为**外边距叠加**。

#### position

1. absolute：元素相对于最近的定位祖先元素进行定位（而不是相对于视口定位，如 fixed）
2. relative：相对于其正常位置进行定位
3. fixed：相对于视口定位，这意味着即使滚动页面，它也始终位于同一位置。top、right、bottom、left 属性用于定位此元素
4. static：默认定位方式，不会以任何特殊方式定位，始终根据页面的正常流进行定位

#### BFC

### 响应式web设计

1. 优势
   1. 网站可用性得到提升，同时与移动优先设计以及内容策略能够非常好的融合在一起
   2. 简化服务器端
   3. 更容易维护
   4. 只提供一个入口给搜索引擎
   5. 能够支持未知设备
2. 缺点
   1. 性能：兼容各种设备工作量大，效率低下；代码累赘，会出现隐藏无用的元素，加载时间变长
   2. 限制应用的复杂性：折中性质的设计解决方案，多方面因素影响而达不到最佳效果
   3. 一定程度上改变了网站原有的布局结构，会出现用户混淆的情况

### 移动优化、渐进将强

1. 优先内容和功能：优先显示最重要的内容和功能，如果空间允许，再逐步加入次要内容和功能
2. 好处：通用访问
   1. 之遥移动端做得好，即使用户使用的是旧版本浏览器、没有 Javascript 或者关闭了 Javascript 的浏览器，或为视力残障人士设计的读屏浏览器，也能看到一个拥有基本功能的网站
   2. 移动优先是渐进将强理念的良好范例，所有用户都能访问核心内容和功能。不存在不能访问的情况
3. 渐进将强基本理念：首先基于一个具有广泛兼容性的核心方案，创建一个基线版本，然后再根据可能用到的浏览器的特性，慢慢添加一些特性和功能。

## Javascript

1. 基本概念
2. 基本语法，变量、类型、数值、String、布尔、null/NaN/undefined、数组、函数等。
3. DOM，BOM
4. 事件，事件驱动编程，事件处理模型（事件流三个阶段）
5. 作用域，词法作用域，作用域链，闭包，提升
6. 最佳实践，正则，原型对象，class，this，框架的优缺点

### DOM、BOM

#### DOM

1. 当一个网页被加载时，浏览器会创建一个页面的文档对象模型（Document Object Model，DOM）
2. HTML DOM 模型被构造成一个对象树
3. 功能：通过对象模型，JavaScript 获得了创建动态 HTML 所需的所有功能
   1. JavaScript 可以更改页面中的所有 HTML 元素
   2. JavaScript 可以更改页面中的所有 HTML 元素
   3. JavaScript 可以更改页面中的所有 CSS 样式
   4. JavaScript 可以删除现有的 HTML 元素和属性
   5. JavaScript 可以添加新的 HTML 元素和属性
   6. JavaScript 可以对页面中所有现有的 HTML 事件做出反应
   7. JavaScript 可以在页面中创建新的 HTML 事件

HTML DOM 是获取、更改、添加或删除 HTML 元素的标准，HTML DOM 定义了：

1. HTML 元素作为对象
2. 所有 HTML 元素的属性
3. 访问所有 HTML 元素的方法
4. 所有 HTML 元素的事件

#### BOM

1. 浏览器对象模型（Browser Object Model，简称BOM）是 JavaScript 的组成部分之一，BOM 赋予了 JavaScript 程序与浏览器交互的能力。
2. 每个浏览器的Javascript程序都可以引用以下全局对象：
   1. document: current HTML page and its content
   2. history: list of pages the user has visited
   3. location: URL of the current HTML page
   4. navigator: info about the web browser you are using
   5. screen: info about the screen area occupied by the browser
   6. window: the browser window

### 事件，事件驱动编程，事件处理模型（事件流三个阶段）

![DOM 事件流](https://img-bed-1309306776.cos.ap-shanghai.myqcloud.com/img/20230222152023.png)

1. Capture Phase（捕获阶段）：事件从 Document 节点自上而下向目标节点传播的阶段
2. Target Phase（目标阶段）：真正的目标节点正在处理事件的阶段
3. Bubbling Phase（冒泡阶段）：事件从目标节点自下而上向 Document 节点传播的阶段
4. 在现代浏览器中，默认情况下，所有事件处理程序都在冒泡阶段进行注册

#### 阻止默认行为

1. 停止事件的传播
   1. `event.stopPropagation()`
   2. `cancelBubble = true`（IE 某些版本）
2. 禁止默认行为：`event.preventDefault()`

### 作用域，词法作用域，作用域链，闭包，提升

#### 作用域

1. 作用域是当前的执行上下文，值和表达式在其中「可见」或者可以被访问，即作用域指的是有权访问的变量集合
   1. 如果一个变量或表达式不在当前的作用域中，那么它是不可用的
   2. 作用域也可以堆叠成层次结构，子作用域可以访问父作用域，反过来则不行
2. JavaScript 的作用域分以下三种
   1. 全局作用域：脚本模式运行所有代码的默认作用域
   2. 模块作用域：模块模式中运行代码的作用域
   3. 函数作用域：由函数创建的作用域
3. 此外，（ES6）用 let 或 const 声明的变量属于额外的作用域
   1. 块级作用域：用一对花括号（一个代码块）创建出来的作用域

#### 变量

1. 在 JavaScript 中，对象和函数也是变量
2. 作用域决定了从代码不同部分对变量、对象和函数的可访问性
3. 在函数之外声明的变量，叫做全局变量，因为它可被当前文档中的任何其他代码所访问
4. 全局变量的作用域是全局的：网页的所有脚本和函数都能够访问它。
5. 自动全局
   1. 如果为尚未声明的变量赋值，此变量会自动成为全局变量。

```javascript
function myFunction() {
   carName = "Volvo";

   // code here can use carName
}
```

#### 函数作用域

1. 在函数内定义的变量不能在函数之外的任何地方访问，因为变量仅仅在该函数的域的内部有定义。
2. 相对应的，一个函数可以访问定义在其范围内的任何变量和函数。
3. 换言之，定义在全局域中的函数可以访问所有定义在全局域中的变量。
4. 在另一个函数中定义的函数也可以访问在其父函数中定义的所有变量和父函数有权访问的任何其他变量

#### 闭包

闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。在 JavaScript 中，闭包会随着函数的创建而被同时创建。

#### 作用域链

#### 变量提升

1. 引擎会在解释 JavaScript 代码之前首先进行编译，编译过程中的一部分工作就是找到所有的声明，并用合适的作用域将他们关联起来，这也正是词法作用域的核心内容
2. JavaScript 变量的另一个不同寻常的地方是，你可以先使用变量稍后再声明变量而不会引发异常。这一概念称为变量提升；JavaScript 变量感觉上是被「提升」或移到了函数或语句的最前面
3. 但是，提升后的变量将返回 `undefined` 值。因此在使用或引用某个变量之后进行声明和初始化操作，这个被提升的变量仍将返回 `undefiend` 值

```javascript
console.log(x === undefined); // true
var x = 3;

// will return a value of undefined
var myVar = "my value";

(function() {
   console.log(myVar);
   var myVar = "local value";
})();
```

#### let 和 const 关键字

1. ES6 新增块级作用域。这个区块对这些变量从一开始就形成了封闭作用域，直到声明语句完成，这些变量才能被访问（获取或设置），否则会报错 ReferenceError
2. 暂时性死区：Temporal Dead Zone，TDZ。即代码块开始到变量声明语句完成之间的区域
3. 注意：通过 let 声明的变量没有变量提升、拥有暂时性死区，作用于块级作用域：
   1. 当进入变量的作用域（包围它的语法块），立即为它创建（绑定）存储空间，不会立即初始化，也不会被赋值
   2. 访问（获取或设置）该变量会抛出异常 `ReferenceError`
   3. 当执行到变量的声明语句时，如果变量定义了值则会被赋值；如果变量没有定义值，则被赋值为 `undefined`

```javascript
{ // TDZ starts at beginning of scope
   console.log(bar); // undefined
   console.log(foo); // ReferenceError
   var bar = 1;
   var foo = 2;   // End of TDZ (for foo)
}
```

> 注意：使用 temporal 是因为区域取决于执行顺序（时间），而不是编写代码的顺序（位置）。比如，下面的代码会生效，是因为即使使用 `let` 变量的函数出现在变量声明之前，但函数的执行是在 TDZ 的外面。
>
> ```javascript
> {
>  // TDZ starts at beginning of scope
>  const func = () => console.log(letVar); // OK
>  // Within the TDZ letVar access throws ReferenceError
>  let letVar = 3;   // End of TDZ (for letVar)
>  func();  // Called outsied TDZ
> }
> ```

对于函数来说，只有函数声明会被提升到顶部，而函数表达式不会被提升。函数和变量相比，会被优先提升。这意味着函数会被提升到更靠前的位置。

```javascript
foo();   // "bar"

function foo() {
   console.log("bar");
}

baz();   // 类型错误，baz 不是一个函数

var baz = function() {
   console.log("bar2");
};
```

### 6. 最佳实践，正则，原型对象，class，this，框架的优缺点

#### 严格模式

1. 严格模式不允许未声明的变量
2. 为什么使用严格模式
   1. 消除 JavaScript 语法的一些不合理、不严谨之处，减少一些怪异行为；
   2. 消除代码运行的一些不安全之处，保证代码运行的安全；
   3. 提高编译器效率，增加运行速度；
   4. 为未来新版本的 JavaScript 做好铺垫
3. ES6 的模块自动采用严格模式，不管模块头部有没有 `use strict`
4. 严格模式有以下的限制
   1. 变量必须声明后再使用
   2. 函数的参数不能有同名属性，否则报错
   3. 不能使用 `with` 语句
   4. 不能对只读属性赋值，否则报错
   5. 不能使用前缀 0 表示八进制数，否则报错
   6. 不能删除不可删除的属性，否则报错
   7. 不能使用 `delete prop` 删除变量，只能删除属性 `delete global[prop]`
   8. eval 不会在它的外层作用域引入变量
   9. eval 和 arguments 不能被重新赋值
   10. arguments 不会自动反映函数参数的变化
   11. 不能使用 arguments.callee
   12. 不能使用 arguments.caller
   13. 禁止 this 指向全局对象
   14. 不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈
   15. 增加了保留字（比如 `protected`、`static` 和 `interface`）

#### 框架

优点：

1. JS 框架封装了复杂困难的代码
2. JS 框架能加快开发速度，更快完成项目
3. JS 框架让你更专注于产品内容的价值，而不是实现过程
4. JS 框架让合作更加简单，大家都对基础代码有共同的理解
5. JS 框架还会强迫你联系，多实践，熟能生巧

缺点：

1. 每个项目的开发都会遇到框架文档没有说明的问题，这时候就要深入框架查找原因，这时候就需要对原生 JavaScript 的深度掌握
2. 新框架频繁发布，更新快速，一旦确定了项目的技术栈，随着时间，如何升级更新是个问题

#### 正则表达式

1. 以 `/` 开始和结束
2. `.` 匹配单个字符，除了换行和行结束符
3. `i` 执行对大小写不敏感的匹配。`/mart/i` 能够匹配 "Marty Stepp"，"smart fellow"
4. `|` 选择匹配
5. `()` 子表达式：把一个表达式分割为几个子表达式时非常有用的
6. `^` 匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置
7. `$` 匹配输入的结束。如果多行标识被设置为 true，那么也匹配换行符前的位置
8. `\` 转义
9. `*` 匹配 0 次或者更多次
10. `+` 匹配 1 次或者更多次
11. `?` 匹配 0 或 1 次
12. `{min, max}` 至少匹配 min 次，至多匹配 max 次。如 `/a(bc){2, 4}/` 表示 bc 最少出现两次，最多出现四次
13. `[]` 匹配包含的字符
14. `[start-end]` 可以使用连字符来指定字符范围，但如果连字符显示为方括号中的第一个或最后一个字符，则它将被视为作为普通字符包含在字符集中的文字连字符。也可以在字符集中包含字符类。
    1. `[^start-end]` 表示一个否定的或者被补充的字符集，匹配任何没有包括在括号中的字符
    2. 字符集中，`-` 需要转义
15. 特殊字符集
    1. `\d` 匹配任何数字，相当于 `[0-9]`。`\D` 匹配任何非数字的字符
    2. `\w` 匹配基本拉丁字母中的任何数字字符，包括下划线，相当于 `[A-Za-z0-9_]`。`\W` 匹配任何不是来自基本拉丁字母的单词字符
    3. `\s` 匹配一个空白字符，包括空格、制表符、换页符、换行符。`\S` 匹配一个非空白字符

#### 函数表达式

// TODO

#### 原型

// TODO

#### this

1. 在函数体中，非显式或隐式地简单调用函数时，在严格模式下，函数内的this会被绑定到undefined上，在非严格模式下则会被绑定到全局对象window/global上。
2. 一般使用 `new` 方法调用构造函数时，构造函数内的this会被绑定到新创建的对象上。
3. 一般通过 `call` / `apply` / `bind` 方法显示调用函数时，函数体内的 `this` 会被绑定到指定参数的对象上。
4. 一般通过上下文对象调用函数时，函数体内的 `this` 会被绑定到该对象上。
5. 在箭头函数中，this的指向是由外层（函数或全局）作用域来决定的。
6. 优先级
   1. 显式绑定：通过 `call`、`apply`、`bind`、`new`
   2. 隐式绑定：根据调用关系确定 this 指向

```javascript
var o1 = {
   text: 'o1',
   fn: function() {
      return this.text;
   }
};

var o2 = {
   text: 'o2',
   fn: function() {
      return o1.fn();
   }
};

var o3 = {
   text: 'o3',
   fn: function() {
      var fn = o1.fn;
      return fn();
   }
};

console.log(o1.fn());
console.log(o2.fn());
console.log(o3.fn());
```

## NODEJS

1. 客户端与服务端编程
2. 静态网页与动态网页
3. Nodejs优势/特点，应用
4. 原理，事件驱动模型
5. 同步IO与异步IO，阻塞与非阻塞
6. 模块，ES6与CommonJS模块
7. Express，路由，中间件，模版引擎
8. Ajax
9. RIA
10. 基本原理，数据格式

### 客户端与服务端编程

#### 静态网页与动态网页

* 静态页面
  * 客户/消费者的观点：一个 url 指向同一个 html 文件
  * 服务器 / 生产者的观点：存储在 Web 服务器根文件夹内或子文件夹内的文件
  * HTML 文件：无论何时当一个特定资源被请求的时候都返回相同的被硬编码的内容
  * 可以直接在浏览器上显示
* 动态页面
  * 客户 / 消费者的观点：url 指的是动态 html（可能每次请求都不同）
  * 服务器 / 生产者的观点：程序 / 脚本生成 html
  * 它不是一个 html，而是一个程序产生的 html（s），页面通常是通过将数据库的数据植入 HTML 模板中的占位符而产生的
  * 不能直接在浏览器中显示

#### 服务端编程

优势：

1. 信息的高效存储和传输
2. 定制用户体验
3. 控制对内容的访问
4. 存储会话和状态信息
5. 通知和通讯
6. 数据分析

### NodeJS

优势：

1. 性能：卓越的性能表现，Node 为优化 web 应用的吞吐量和扩展度而生，对常见的 web 开发问题是一套绝佳方案（比如实时 web 应用）
2. 技术栈：代码还是熟悉的老伙伴 JavaScript，这意味着在客户端和服务器端「上下文切换」的时间成本更低
3. 新语言：与传统的 web 服务器语言（例如 Python、PHP 等）相比，JavaScript 理念更新，语言设计的改进带来了诸多好处。许多其它新近流行的语言也可编译/转换成 JavaScript，所以  TypeScript、CoffeeScript、ClojureScript、Scala、LiveScript 等等也可以使用。
4. NPM：Node 包管理工具（node package manager，NPM）提供了数十万个可重用的工具包。它还提供了一流的依赖解决方案，可实现自动化工具链构建。
5. 可移植：Node.js 是可移植的，可运行于 Microsoft Windows、macOS、Linux、Solaris、FreeBSD、OpenBSD、WebOS 和 NonStop OS。此外，许多 web 主机供应商对其提供了良好支持（包括专用的基础框架和构建 Node 站点的文档）。
6. 生态：活跃的第三方生态系统和开发者社区，很多人愿意提供帮助

特点：

1. DIRT：数据密集型实时程序（data-intensive real-time）
2. 性能和 I/O 负载：NodeJS 非常好的解决了 IO 密集的问题，通过异步 IO 来实现
3. 大前端的基石
4. 从脚手架、辅助前端开发（比如 SSR、PWA 等）的快速开发实践，到 API 中间层、代理层，到专业的后端开发都有非常成熟的经验
5. 全栈

### 事件驱动模型

// TODO

### 同步与异步 I/O，阻塞与非阻塞

| 同步式 I/O（阻塞式）                 | 异步式 I/O（非阻塞式）     |
| ------------------------------------ | -------------------------- |
| 利用多线程提供吞吐量                 | 单线程即可实现高吞吐量     |
| 通过时间片分割和线程调度利用多核 CPU | 通过功能划分利用多核 CPU   |
| 需要由操作系统调度多线程使用多核 CPU | 可以将单进程绑定到单核 CPU |
| 难以充分利用 CPU 资源                | 可以充分利用 CPU 资源      |
| 内存轨迹大，数据局部性弱             | 内存轨迹小，数据局部性强   |
| 符合线性的编程思维                   | 不符合传统编程思维         |

1. 阻塞：在 NodeJS 程序中，其他 JavaScript 语句的执行，必须等待一个非 JavaScript 操作完成。这是因为当阻塞发生时，事件循环无法继续运行 JavaScript
2. 在 NodeJS 中，JavaScript 由于执行 CPU 密集型操作，而不是等待一个非 JavaScript 操作（例如 I/O） 而表现不佳，通常不被称为阻塞。在 NodeJS 标准库中使用 libuv 的同步方法是最常用的阻塞操作。原生模块中也有阻塞方法
3. 在 NodeJS 标准库中的所有 I/O 方法都提供异步版本，非阻塞，并且接受回调函数。某些方法也有对应的阻塞版本，名字以 `Sync` 结尾

### 模块、ES6与 CommonJS 模块

#### ES6 模块与 CommonJS 模块的差异

1. 语法：
   1. CommonJS 模块使用 `require()` 加载和 `module.exports` 输出
   2. ES6 模块使用 `import` 和 `export`
2. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用
3. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口
   1. CommonJS 加载的是一个对象（即 `module.exports` 属性），该对象只有在脚本运行完才会生成
   2. ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成

#### Node.js 的区分

1. Node.js 要求 ES6 模块采用.mjs后缀文件名。
   1. 只要脚本文件里面使用import或者export命令，那么就必须采用.mjs后缀名。
   2. Node.js 遇到.mjs文件，就认为是 ES6 模块，默认启用严格模式，不必在每个模块文件顶部指定"use strict"。
   3. 如果不希望将后缀名改成.mjs，可以在项目的package.json文件中，指定type字段为module。
2. .cjs文件总是以 CommonJS 模块加载
   1. 如果没有type字段，或者type字段为commonjs，则.js脚本会被解释成 CommonJS 模块。
3. .js文件的加载取决于package.json里面type字段的设置。
4. 注意，ES6 模块与 CommonJS 模块尽量不要混用！！！
   1. require命令不能加载.mjs文件，会报错，只有import命令才可以加载.mjs文件。
   2. 反之，.mjs文件里面也不能使用require命令，必须使用import。

### Express、路由、中间件、模板引擎

1. 路由用于确定应用程序如何响应对特定端点的客户机请求，包含一个 URI（或路径）和一个特定的 HTTP 请求方法（GET、POST 等）。
2. 每个路由可以具有一个或多个处理程序函数，这些函数在路由匹配时执行。
3. 路由定义采用以下结构：
   1. app.METHOD(PATH, HANDLER) 其中：
      1. app 是 express 的实例。
      2. METHOD 是 HTTP 请求方法。
      3. PATH 是服务器上的路径。
      4. HANDLER 是在路由匹配时执行的函数。
4. 特殊路由方法 `app.all()`：该方法用于在所有请求方法的路径中装入中间件函数。

```javascript
var express = require('express');
var app = express();

app.get('/', function(req, res) {
   res.send('Hello World');
});

app.listen(3000, function() {
   console.log('Example app listening on port 3000!');
});
```

#### 路由路径

1. 路由路径与请求方法相结合，用于定义可以在其中提出请求的端点。路由路径可以是字符串、字符串模式或正则表达式。  
2. 路由路径用于定义可请求的端点。之前示例中路径都是字符串，并且必须精确写为：'/'、'/ about'、'/ book'，等等。
3. 路由路径也可以是字符串模式（String Pattern）。可用部分正则表达式语法来定义端点的模式。以下是所涉及的正则表达式（注意，连字符（ -）和点（.）在字符串路径中解释为字面量，不能做为正则表达式）：
   1. `?`：问号之前的一个字符只能出现零次或一次。例如，路由路径 `/ab?cd` 路径匹配端点 acd 或 abcd
   2. `+`：加号之前的一个字符至少出现一次。例如，路径路径 `/ab+cd` 匹配端点abcd、abbcd、abbbcd等
   3. `*`：星号可以替换为任意字符串。例如，路由路径 `/ab*cd` 匹配端点 abcd、abXcd、abSOMErandomTEXTcd等
   4. `()`：将一个字符串视为一体以执行 ?、+、* 操作。例如。 `/ab(cd)?e` 将对 (cd) 进行匹配，将匹配到 abe 和 abcde
4. 路由路径也可以是 JavaScript 正则表达式。例如，下面的路由路径将匹配 catfish 和 dogfish，但不会匹配 catflap、catfishhead 等。注意，正则表达式路径不再用引号 "..." 括起来，而是正则表达式语法 /.../。`app.get(/.*fish$/, (req, res) => {...});`

#### 路由参数

1. 路径参数是命名的 URL 段，用于捕获在 URL 中的位置指定的值。命名段以冒号为前缀，然后是名称（例如 /:your_parameter_name/。捕获的值保存在 req.params 对象中，键即参数名（例如 req.params.your_parameter_name）。
2. 路由参数名必须由“单词字符”（/[A-Za-z0-9_]/）组成。

```javascript
app.get('/users/:userId/books/:bookId', (req, res) => {
   // 通过 req.params.userId 访问 userId
   // 通过 req.params.bookId 访问 bookId
   res.send(req.params);
})
```

#### 路由处理程序

1. 可以提供多个回调程序，以类似于中间件的行为方式来处理请求。唯一例外是这些回调函数可能调用 `next('route')` 来绕过剩余的路由回调。可以使用此机制对路由施加先决条件，在没有理由继续执行当前路由的情况下，可将控制权传递给后续路由
2. 路由处理程序的形式可以是一个函数、一组函数或者两者的结合，如以下示例中所示

```javascript
app.get('/example/a', function (req, res) {
   res.send('Hello from A!');
});

// 多个回调函数可以处理一个路由（确保指定 next 对象）
app.get('/example/b', function(req, res, next) {
   console.log('the response will be sent by the next function...');
   next();
}, function(req, res) {
   res.send('Hello from B!');
});
```

#### 响应方法

| 方法               | 描述                                           |
| ------------------ | ---------------------------------------------- |
| `res.download()`   | 提示将要下载文件                               |
| `res.end()`        | 结束响应进程                                   |
| `res.json()`       | 发送 JSON 响应                                 |
| `res.jsonp()`      | 在 JSONP 的支持下发送 JSON 响应                |
| `res.redirect()`   | 重定向请求                                     |
| `res.redirect()`   | 重定向请求                                     |
| `res.render()`     | 呈现视图模板                                   |
| `res.send()`       | 发送各种类型的响应                             |
| `res.sendFile()`   | 以八位元流形式发送文件                         |
| `res.sendStatus()` | 设置响应状态码并以响应主体形式发送其字符串表示 |

#### 中间件

1. Connect创造了“中间件”(middleware)这个术语来描述插入式的Node模块
2. 从概念上讲，中间件是一种功能的封装方式，具体来说就是封装在程序中处理HTTP请求的功能。
3. 中间件是在管道中执行的。在 Express 程序中，通过调用 `app.use` 向管道中插入中间件。
4. 中间件函数能够访问请求对象 (req)、响应对象 (res) 以及应用程序的请求/响应循环中的下一个中间件函数。下一个中间件函数通常由名为 next 的变量来表示。
5. 中间件函数可以执行以下任务：
   1. 执行任何代码。
   2. 对请求和响应对象进行更改。
   3. 结束请求/响应循环。
   4. 调用堆栈中的下一个中间件函数。
6. 如果当前中间件函数没有结束请求/响应循环，那么它必须调用 `next()`，以将控制权传递给下一个中间件函数。否则，请求将保持挂起状态。
7. Express 应用程序可以使用以下类型的中间件
   1. 应用层中间件
   2. 路由器层中间件
   3. 错误处理中间件
   4. 内置中间件
   5. 第三方中间件
8. 可以使用可选安装路径来装入应用层和路由器层中间件。还可以将一系列中间件函数一起装入，这样在安装点创建中间件系统的子堆栈

#### 模板引擎

### Ajax

### RIA

![MVC RIA](https://img-bed-1309306776.cos.ap-shanghai.myqcloud.com/img/20230222224247.png)

优势：

1. 不需要安装
2. 易于升级
3. 可以通过互联网/内部网轻松获得
4. 丰富的用户界面
5. 更好的响应性
6. 客户机/服务器平衡
7. 异步通信
8. 网络效率

不足：

1. 搜索引擎不够友好
2. 专有的
3. 完整性丧失（RIA 通常不能很好地与 HTML 混合）
4. 软件开发的复杂性（在客户端计算机上缓存或不缓存什么？）
5. RIA 体系结构打破了 Web 页面范式

## HTTP

1. HTTP1/2/3
2. 基本原理，为何演进，常用的请求方法、头域、状态码

### HTTP/2

1. HTTP/2 是 HTTP 网络协议的一个重要版本。HTTP/2 的主要目标是：
   1. 通过启用完整的请求和响应多路复用来减少延迟
   2. 通过有效压缩 HTTP 标头字段（header）来最小化协议开销
   3. 增加对请求优先级和服务器推送的支持
2. HTTP/2 不会修改 HTTP 协议的语义。HTTP 1.1 中的所有核心概念（例如 HTTP 方法，状态码，URI 和 headers）都得以保留。而是修改了 HTTP/2 数据在客户端和服务器之间的格式（帧）的传输方式，这两者都管理整个过程，并在新的框架层内隐藏了应用程序的复杂性。所以，所有现有的应用程序都可以不经修复地交付。

### HTTP 事务延迟

影响 HTTP 的常见的与 TCP 相关的延迟

1. TCP 连接建立（三次握手）
2. TCP 慢启动拥塞机制
3. Nagle 的数据聚合算法
4. TCP 用于承载确认的延迟确认算法
5. TIME_WAIT 延迟和端口耗尽

### HTTP/1.x 的连接管理

![20230223001153](https://img-bed-1309306776.cos.ap-shanghai.myqcloud.com/img/20230223001153.png)

1. 短连接：
   1. 每一个 HTTP 请求都由它自己独立的连接完成；这意味着发起每一个 HTTP 请求之前都会有一次 TCP 握手，而且是连续不断的。
   2. 这是 HTTP/1.0 的默认模型（如果没有指定 Connection 协议头，或者是值被设置为 close）。而在 HTTP/1.1 中，只有当 Connection 被设置为 close 时才会用到这个模型
   3. 短链接有两个比较大的问题：创建新连接耗费的时间尤为明显，另外 TCP 连接的性能只有在该连接被使用一段时间后（热连接）才能得到改善
2. 长连接/持久连接
   1. 一个⻓连接会保持一段时间，重复用于发送一系列请求，节省了新建TCP 连接握手的时间，还可以利用 TCP 的性能增强能力。当然这个连接也不会一直保留着：连接在空闲一段时间后会被关闭 (服务器可以使用 Keep-Alive 协议头来指定一个最小的连接保持时间)。
   2. 长连接也是有缺点的；就算是在空闲状态，它还是会消耗服务器资源，而且在重负载的时候，还有可能遭受 DoS attacks 攻击。在这种场景下，可以使用非长连接，即尽快关闭那些空闲的连接，也能对性能有所提升。
   3. HTTP/1.0 里默认并不使用长连接。把 Connection 设置成 close 以外的其他参数都可以让其保持长连接，通常会设置为 retry-after
   4. 在 HTTP/1.1 里，默认就是长连接的，协议头都不用再去声明它（但我们还是会把它加上，万一某个时候因为某种原因要退回到 HTTP/1.0 呢）
3. HTTP 流水线
   1. 默认情况下，HTTP 请求是按顺序发出的。下一个请求只有在当前请求收到应答过后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很⻓时间。
   2. 流水线是在同一条⻓连接上发出连续的请求，而不用等待应答返回。这样可以避免连接延迟。理论上讲，性能还会因为两个 HTTP 请求有可能被打包到一个 TCP 消息包中而得到提升。就算 HTTP 请求不断的继续，尺寸会增加，但设置 TCP 的 MSS(Maximum Segment Size) 选项，仍然足够包含一系列简单的请求。
   3. 并不是所有类型的 HTTP 请求都能用到流水线：只有 idempotent 方式，比如 GET、HEAD、PUT 和 DELETE 能够被安全的重试：如果有故障发生时，流水线的内容要能被轻易的重试。
   4. 今天，所有遵循 HTTP/1.1 的代理和服务器都应该支持流水线，虽然实际情况中还是有很多限制：一个很重要的原因是，目前没有现代浏览器默认启用这个特性。

### HTTP 事务

### HTTP 消息

### HTTP 请求方法

1. GET：从服务器获取 URL 对应的资源
2. HEAD：除了服务器响应中不能包含消息体，该方法与 GET 一样。用于只需少数元信息的情况
3. POST：被设计用来注解、修改 URL 所对应资源
4. PUT：被设计用来修改或创建资源。当 URL 对应的资源存在时，则提交的作为新版本，否则新建资源
5. DELETE：被设计用来删除 URL 对应资源
6. TRACE：主要用来测试。服务器将最终收到的请求本身发送回来，作为客户端诊断依据
7. OPTIONS：客户端查询服务器对与某 URL 允许的通信选项
8. CONNECT：保留的方法名，用于代理切换隧道

### 头域

1. 由主键/值对组成，描述客户端或者服务器的属性、被传输的资源以及应该实现连接。
2. 四种不同类型的头标：
   1. 通用头标：即可用于请求，也可用于响应，是作为一个整体而不是特定资源与事务相关联。
   2. 请求头标：允许客户端传递关于自身的信息和希望的响应形式。
   3. 响应头标：服务器和于传递自身信息的响应。
   4. 实体头标：定义被传送资源的信息。即可用于请求，也可用于响应。

### 状态码

1. 200: OK
2. 204: No Content
3. 400: Bad Request
4. 401: Unauthorized
5. 403: Forbidden
6. 404: Not Found
7. 405: Method Not Allowed
8. 500: Internal Server Error

### Body

1. 请求/响应的最后一部分是它的 body
   1. 不是所有的请求都有一个 body：例如获取资源的请求，GET，HEAD，DELETE 和 OPTIONS，通常它们不需要 body。有些请求将数据发送到服务器以便更新数据：常⻅的的情况是 POST 请求（包含 HTML 表单数据）。
   2. 不是所有的响应都有 body：具有状态码 (如 201 或 204) 的响应，通常不会有 body。
2. 任何信息
3. 需要Content-Length、Content-Type

### HTTP1/2/3

1. HTTP/1.x 报文有一些性能上的缺点
   1. Header 不像 body，它不会被压缩
   2. 两个报文之间的 header 通常非常相似，但它们仍然在连接中重复传输
   3. 无法复用。当在同一个服务器打开几个连接时，TCP 热连接比冷连接更加有效
2. HTTP/2：SPDY 成为了 HTTP/2 协议的基础，它与 HTTP/1.1 有几处基本的不同
   1. HTTP/2 是二进制协议而不是文本协议。不再可读，也不可无障碍的手动创建，改善的优化技术现在可被实施。
   2. 这是一个复用协议。并行的请求能在同一个链接中处理，移除了 HTTP/1.x 中顺序和阻塞的约束。
   3. 压缩了 headers。因为 headers 在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。
   4. 其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。
3. HTTP/3：为何需要 HTTP/3
   1. TCP 队头阻塞问题
   2. TCP 握手时长
   3. 移动场景的网络切换成本：IP 地址会发生变化，而 TCP 协议是根据四元组来确定一个连接的，需要重新建立连接
   4. HTTP/3基于UDP协议重新定义了连接，在QUIC层实现了无序、并发字节流的传输，解决了队头阻塞问题（包括基于QPACK解决了动态表的队头阻塞）；
   5. HTTP/3重新定义了TLS协议加密QUIC头部的方式，既提高了网络攻击成本，又降低了建立连接的速度（仅需1个RTT就可以同时完成建链与密钥协商）；
   6. HTTP/3将Packet、QUIC Frame、HTTP3 Frame分离，实现了连接迁移功能，降低了5G环境下高速移动设备的连接维护成本。

## 性能优化

1. 要点，常用术语，浏览器渲染机制，性能分析方法，最佳实践

### 要点

1. 延迟和带宽对 Web 性能的影响
2. 传输协议（TCP）对 HTTP 的限制
3. HTTP 协议自身的功能和缺陷
4. Web 应用的发展趋势及性能要求
5. 浏览器局限性和优化思路
6. 不同层之间总是相互依赖， 但优化方式却有很多可能性。任何优化建议和最佳做法都不是一成不变的，涉及的每个要素都是动态发展的:
   1. 浏览器越来越快
   2. 用户上网条件不断改善
   3. Web应用的功能和复杂度也与日俱增

### 常用术语

1. 延迟：分组从信息源发送到目的地所需的时间
   1. 传播延迟：消息从发送端到接收端需要的时间,是信号传播距离和速度的函数
   2. 传输延迟：把消息中的所有比特转移到链路中需要的时间,是消息⻓度和链路速率的函数
   3. 处理延迟：处理分组首部、检查位错误及确定分组目标所需的时间
   4. 排队延迟：到来的分组排队等待处理的时间
2. 带宽：逻辑或物理通信路径最大的吞吐量

### 浏览器页面渲染机制

#### 导航

1. DNS 查询
2. TCP 握手：一旦获取到服务器 IP 地址，浏览器就会通过 TCP 三次握手与服务器建立连接。TCP 的三次握手技术经常被称为「SYN-SYN-ACK」
3. TLS 协商：为了在 HTTPS 上建立安全连接，另一种握手是必须的。更确切的说是 TLS 协商，它决定了什么密码将会被用来加密通信，验证服务器，在进行真实的数据传输之前建立安全连接。在发送真正的请求内容之前还需要三次往返服务器。

#### 响应

1. 初始请求的响应包含所接收数据的第一个字节。Time to First Byte（TTFB）是用户通过点击链接进行请求与收到第一个 HTML 数据包之间的时间
2. 初始页面加载的 14KB 规则，第一个内容分块通常是 14KB 的数据。
3. TCP 慢启动 / 14KB 规则：
   1. 第一个响应数据包是 14KB 大小的。这是慢启动的一部分，慢启动是一种均衡网络连接速度的算法。慢启动逐渐增加发送数据的数量直到达到网络的最大带宽。
   2. 在 TCP 慢启动中，在收到初始包之后，服务器会将下一个数据包的大小加倍到 28KB。后续的数据包依次是前一个包大小的二倍直到达到预定的阈值，或者遇到阻塞。

#### 解析

一旦浏览器收到数据的第一块，它就可以开始解析收到的信息。“解析”是浏览器将通过网络接收的数据转换为 DOM 和 CSSOM 的步骤，通过渲染器把 DOM 和 CSSOM 在屏幕上绘制成⻚面

#### 构建 DOM 树

1. 第一步是处理 HTML 标记并构造 DOM 树。HTML 解析涉及到 tokenization 和树的构造。
2. 当解析器发现非阻塞资源，例如一张图片，浏览器会请求这些资源并且继续解析。当遇到一个 CSS 文件时，解析也可以继续进行，但是对于 `<script>` 标签（特别是没有 async 或者 defer 属性的）会阻塞渲染并停止 HTML 的解析。尽管浏览器的预加载扫描器加速了这个过程，但过多的脚本仍然是一个重要的瓶颈。

#### 预加载扫描器

浏览器构建 DOM 树时，这个过程占用了主线程。当这种情况发生时，预加载扫描仪将解析可用的内容并请求高优先级资源，如 CSS、JavaScript 和 web 字体。多亏了预加载扫描器，我们不必等到解析器找到对外部资源的引用来请求它。它将在后台检索资源，以便在主 HTML 解析器到达请求的资源时，它们可能已经在运行，或者已经被下载。预加载扫描仪提供的优化减少了阻塞。

#### 构建 CSSOM 树

1. CSS 对象模型，简称为 CSSOM
2. 第二步是处理 CSS 并构建 CSSOM 树。CSS 对象模型和 DOM 是相似的。DOM 和 CSSOM 是两棵树。它们是独立的数据结构。浏览器将 CSS 规则转换为可以理解和使用的样式映射。浏览器遍历 CSS 中的每个规则集，根据 CSS 选择器创建具有父、子和兄弟关系的节点树。

#### 其他过程

1. JavaScript 编译
   1. 当 CSS 被解析并创建 CSSOM 时，其他资源，包括 JavaScript 文件正在下载（借助预加载扫描器）。JavaScript 被解释、编译、解析和执行。脚本被解析为抽象语法树。一些浏览器引擎使用抽象语法树并将其传递到解释器中，输出在主线程上执行的字节码。这就是所谓的JavaScript 编译。
2. 构建辅助功能树
   1. 浏览器还构建辅助设备用于分析和解释内容的辅助功能（accessibility）树。无障碍对象模型（AOM）类似于 DOM 的语义版本。当 DOM 更新时，浏览器会更新辅助功能树。辅助技术本身无法修改无障碍树。
   2. 在构建 AOM 之前，屏幕阅读器（screen readers (en-US)）无法访问内容。

#### 渲染

渲染步骤包括样式、布局、绘制，在某些情况下还包括合成。在解析步骤中创建的 CSSOM 树和 DOM 树组合成一个 Render 树，然后用于计算每个可⻅元素的布局，然后将其绘制到屏幕上。在某些情况下，可以将内容提升到它们自己的层并进行合成，通过在 GPU 而不是 CPU 上绘制屏幕的一部分来提高性能，从而释放主线程。

##### 样式

1. 第三步是将 DOM 和 CSSOM 组合成一个 Render 树，计算样式树或渲染树从 DOM 树的根开始构建，遍历每个可⻅节点。
2. 像 `<head>` 和它的子节点以及任何具有 display: none 样式的结点，例如 script { display: none; }（在 user agent stylesheets 可以看到这个样式）这些标签将不会显示，也就是它们不会出现在 Render 树上。具有 visibility: hidden 的节点会出现在 Render 树上，因为它们会占用空间。由于我们没有给出任何指令来覆盖用户代理的默认值，因此上面代码示例中的 script 节点将不会包含在 Render 树中。
3. 每个可⻅节点都应用了其 CSSOM 规则。Render 树保存所有具有内容和计算样式的可⻅节点——将所有相关样式匹配到 DOM 树中的每个可⻅节点，并根据 CSS 级联确定每个节点的计算样式。

##### 布局

1. 第四步是在渲染树上运行布局以计算每个节点的几何体。布局（Layout）是确定呈现树中所有节点的宽度、高度和位置，以及确定⻚面上每个对象的大小和位置的过程。回流（reflow）是对⻚面的任何部分或整个文档的任何后续大小和位置的确定。
   1. 第一次确定节点的大小和位置称为布局
   2. 随后对节点大小和位置的重新计算称为回流
2. 构建渲染树后，开始布局。渲染树标识显示哪些节点（即使不可⻅）及其计算样式，但不标识每个节点的尺寸或位置。为了确定每个对象的确切大小和位置，浏览器从渲染树的根开始遍历它。

##### 绘制

1. 最后一步是将各个节点绘制到屏幕上，第一次出现的节点称为 first meaningful paint (en-US)。在绘制或光栅化阶段，浏览器将在布局阶段计算的每个框转换为屏幕上的实际像素。
2. 为了确保平滑滚动和动画，占据主线程的所有内容，包括计算样式，以及回流和绘制，必须让浏览器在 16.67 毫秒内完成。
3. 为了确保重绘的速度比初始绘制的速度更快，屏幕上的绘图通常被分解成数层。如果发生这种情况，则需要进行合成。
4. 绘制可以将布局树中的元素分解为多个层。将内容提升到 GPU 上的层（而不是 CPU 上的主线程）可以提高绘制和重新绘制性能。
5. 分层确实可以提高性能，但是它以内存管理为代价，因此不应作为 web 性能优化策略的一部分过度使用。
6. 当文档的各个部分以不同的层绘制，相互重叠时，必须进行合成，以确保它们以正确的顺序绘制到屏幕上，并正确显示内容。

#### 交互

1. 一旦主线程绘制⻚面完成，你会认为我们已经“准备好了”，但事实并非如此。如果加载包含 JavaScript（并且延迟到 onload 事件激发后执行），则主线程可能很忙，无法用于滚动、触摸和其他交互。
2. Time to Interactive (en-US)（TTI）是测量从第一个请求导致 DNS 查询和 SSL 连接到⻚面可交互时所用的时间——可交互是 First Contentful Paint (en-US) 之后的时间点，⻚面在 50ms 内响应用户的交互。如果主线程正在解析、编译和执行 JavaScript，则它不可用，因此无法及时（小于 50ms）响应用户交互。
3. 每当浏览器遇到脚本标签时，DOM 构造就会暂停！整个 DOM 构建过程都将停止，直到脚本执行完成。
   1. JavaScript 可以同时修改 DOM 和 CSSOM
4. 在默认情况下，每个脚本都是一个解析器阻断器！
   1. 例外，async

#### 关键渲染路径

1. 周密的关键渲染路径（CRP）优化策略使浏览器能够通过确定优先加载的资源以及资源加载的顺序来尽可能地加载页面
2. 优化 CRP
   1. 提升页面加载速度需要通过被加载资源的优先级、控制它们加载的顺序和减小这些资源的体积。性能提示包含：
      1. 通过异步、延迟加载或者消除非关键资源来减少关键资源的请求数量
      2. 优化必须的请求数量和每个请求的文件体积
      3. 通过区分关键资源的优先级来优化被加载关键资源的顺序，来缩短关键路径长度

### 性能监控指标

1. FP（全称“First Paint”，“首次绘制”） ：对于应用⻚面，首次出现视觉上不同于跳转之前内容的时间点，或者说是⻚面发生第一次绘制的时间点。
2. FCP（全称“First Contentful Paint”，“首次内容绘制”）：指浏览器完成渲染DOM中第一部分内容（可能是文本、图像或其他任何元素）的时间点，此时用户应该在视觉上有直观的感受。
   1. 注意：只有首次绘制文本、图片（包含背景图）、非白色的canvas或SVG时才被算作FCP。
3. FP与FCP这两个指标之间的主要区别是：
   1. FP是当浏览器开始绘制内容到屏幕上的时候，只要在视觉上开始发生变化，无论是什么内容触发的视觉变化，在这一刻，这个时间点，叫做FP。
   2. 相比之下，FCP指的是浏览器首次绘制来自DOM的内容。例如：文本，图片，SVG，canvas 元素等，这个时间点叫FCP。
   3. FP和FCP可能是相同的时间，也可能是先FP后FCP。
4. FMP（全称“First Meaningful Paint”，翻译为“首次有意义绘制”） ：指⻚面关键元素的渲染时间。
   1. 没有标准化定义，因为关键元素可以由开发者自行定义。
   2. FMP本质上是通过一个算法来猜测某个时间点可能是FMP，所以有时候不准。
5. 首屏时间：进入页面之后，应用渲染完成整个手机屏幕（未滚动之前）内容的时间。业界对于这个指标没有确切定论，比如是否包含屏幕内图片的渲染完成时间。
6. 用户可交互时间：用户可以与应用进行交互的时间
   1. 一般来说，是 DOM Ready 的时间，因为通常会在这时绑定时间操作
   2. 如果页面中涉及交互的脚本没有下载完成，那么当然没有到达所谓的用户可交互时间
7. 总下载时间：页面所有资源加载完成所需要的时间。
   1. 一般可以统计 `window.onload` 的时间，这样可以统计出同步加载资源全部加载完的耗时
   2. 如果页面中存在较多的异步渲染，那么可以将异步渲染全部完成的时间做为总下载时间
8. 自定义指标

### 浏览器优化的四种技术

1. 资源预取和排定优先次序：文档、CSS 和 JavaScript 解析器可以与网络协议层沟通，声明每种资源的优先级:初始渲染必需的阻塞资源具有最高优先级，而低优先级的请求可能会被临时保存在队列中。
2. DNS预解析：对可能的域名进行提前解析，避免将来 HTTP 请求时的 DNS 延迟。预解析可以通过学习导航历史、用户的鼠标悬停，或其他⻚面信号来触发。
3. TCP预连接：DNS 解析之后，浏览器可以根据预测的 HTTP 请求，推测性地打开 TCP 连接。 如果猜对的话，则可以节省一次完整的往返(TCP 握手)时间。
4. ⻚面预渲染：某些浏览器可以让我们提示下一个可能的目标，从而在隐藏预先渲染 整个⻚面。这样，当用户真的触发导航时，就能立即切换过来

### 最佳实践

1. 消除或减少不必要的网络延迟
2. 将需要传输的数据压缩至最少

#### 性能准则

1. 减少DNS查找：每一次主机名解析都需要一次网络往返,从而增加请求的延迟时间,同时还会阻塞后续请求。
2. 重用TCP连接：尽可能使用持久连接,以消除 TCP 握手和慢启动延迟。
3. 减少HTTP重定向：HTTP 重定向极费时间,特别是不同域名之间的重定向,更加费时;这里面既有额外的 DNS 查询、TCP 握手,还有其他延迟。最佳的重定向次数为零。
4. 使用CDN(内容分发网络)：把数据放到离用户地理位置更近的地方,可以显著减少每次 TCP 连接的网络延迟,增大吞吐量。这一条既适用于静态内容,也适用于动态内容。
5. 去掉不必要的资源：任何请求都不如没有请求快。

#### 其他准则

1. 在客户端缓存资源：应该缓存应用资源,从而避免每次请求都发送相同的内容。
2. 传输压缩过的内容：传输前应该压缩应用资源,把要传输的字节减至最少:确保对每种要传输的资源 采用最好的压缩手段。
3. 消除不必要的请求开销：减少请求的 HTTP 首部数据(比如 HTTP cookie),节省的时间相当于几次往返 的延迟时间。
4. 并行处理请求和响应：请求和响应的排队都会导致延迟,无论是客户端还是服务器端。这一点经常被忽视,但却会无谓地导致很⻓延迟。
5. 针对协议版本采取优化措施：HTTP 1.x 支持有限的并行机制,要求打包资源、跨域分散资源,等等。相对而 言,HTTP/2.0 只要建立一个连接就能实现最优性能,同时无需针对 HTTP 1.x 的那些优化方法。

## 前端鉴权

1. 术语：认证、授权、鉴权、权限控制、SSO、OAuth2.0
2. 不同的方案，各自的流程，优缺点。

### 术语

1. 认证（Identification）：根据声明者所持有的识别信息，确认声明者身份
2. 授权（Authorization）：在信息安全领域是指资源所有者委派执行者，赋予执行者指定范围的资源操作权限，以便对资源的相关操作。
   1. 互联网授权机制：web 服务器的 session 机制、web 浏览器的 cookie 机制、颁发授权令牌（token）等
3. 鉴权（Authentication）：在信息安全领域是指对于一个声明者所声明的身份权利，对其所声明的真实性进行鉴别确认的过程。

### 方案

1. HTTP 基本健全
2. session-cookie 鉴权
3. Token
4. JWT
5. SSO（Single Sign On）
6. OAuth2.0： 是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站；

## 登录注册

1. 验证码、密码、其他要点

### 加密

1. 对称加密：加密、解密用相同的秘钥。
   1. 优点是算法公开、加密速度快、效率高；缺点是不安全
   2. 使用场景：保存手机号等需解密的信息
   3. 常见算法： AES、DES、RC4、RC5、RC6
2. 非对称加密：加密使用公钥，解密使用私钥。私钥签名，公钥可验证是否被篡改
   1. 优点是安全性高；缺点是加密解密时间长、速度慢
   2. 使用场景：用于签名或认证
   3. 常见算法：RSA、DSA
3. 不可逆加密算法：加密后不能反向解密
   1. 使用场景：储存用户敏感信息，比如密码、银行账号
   2. 常见算法：MD5、SHA

常见的七种加密方式

| 算法     | 特点           | 有效破解方式 | 破解难度 | 其它               |
| -------- | -------------- | ------------ | -------- | ------------------ |
| 对称加密 | 可以解密出明文 | 获取密钥     | 中       | 需要确保密钥不泄露 | $nbsp; |
| 单向HASH | 不可解密       | 碰撞、彩虹表 | 中       |
| 特殊HASH | 不可解密       | 碰撞、彩虹表 | 中       | 需要确保“盐”不泄露 |
| Pbkdf2   | 不可解密       | 无           | 难       | 需要设定合理的参数 |
| BCrypt   | 不可解密       | 无           | 难       | 需要设定合理的参数 |
| SCrypt   | 不可解密       | 无           | 难       | 需要设定合理的参数 |
| Argon2   | 不可解密       | 无           | 难+      |                    |

### 其他要点

略，太多了

## 前端主题切换

1. 不同方案

略，太多了

试题中，简单和问答题有选用
